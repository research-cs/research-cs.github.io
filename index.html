<!-- This is the starting page for the survey.-->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">

  <title>Study</title>
  <script src="https://proliferate.alps.science/static/js/proliferate.js" type="text/javascript"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js"></script>

  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0-beta.3/tex-mml-chtml.js">
  </script>
  <script>
    MathJax = {
      loader: {load: ["input/tex", "output/chtml"]},
      tex: {
        inlineMath: [['$$', '$$']],
      },
      "HTML-CSS": {
                  
      } 
    };
  </script>

  <style>

html, body {margin: 0; height: 100%;}

body {
  padding-top: 6.9vh;
  background-color: white;
}

#top-bar {
  height: 6.9vh;
}

.screen {
   height: 100vh;
}

#bottom-bar {
   height: 0px;
}

.feed-container {
   border:rgba(0, 0, 0, .5);
}

.feed-label {
   z-index: 1;
   width: 100%;
   margin: 0 auto;
   border-radius: 5px;
   display: flex;
   justify-content: center;
   align-items: center;
}

.label-container {
   background-color: #eee;
}

label {
   cursor: pointer;
}

input {
   cursor: pointer;
}

img {
   max-height: 50vh;
   width: auto;
}
 
#next-btn {
   height: 40px;
   width: 60px;
   margin-top: -9vh;
   margin-right: 2vh;
   z-index: 50;
 }

 .selected-label {
   color: white;
 }
 

 .visible-scrollbar::-webkit-scrollbar {
   -webkit-appearance: none;
   width: 9px;
 }

.visible-scrollbar::-webkit-scrollbar-thumb {
   border-radius: 4px;
   background-color: rgba(0, 0, 0, .5);
   -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);
 }

.feed-scroll {
  border: 2px solid #ccc;
  padding-bottom: -100px !important;
  scroll-padding-bottom: 0;
  border-radius: 5px;
  max-height: 87vh;
  overflow: scroll;
}

.question-container {
   max-height: 700px; 
   width: 230px; 
   word-wrap: break-word; 
}
 
 .time {
   font-size: 3px !important;
 }
 
 .post {
   padding: 8px;
   margin: 5px 0;
   border: 1px solid #ccc;
   border-radius: 6px;
 }

 .author-info {
   display: flex;
   align-items: center;
 }

 .author-info img {
   width: 35px;
   height: 35px;
   border-radius: 50%;
   margin-right: 10px;
 }

 .post .font-weight-bold {
   font-size: 14px;
 }

 .post .small-text {
   font-size: 12px;
   color: #888;
 }

 .post .xs-text {
   font-size: 10px;
   color: #888;
 }

 .post .socials {
   justify-content: flex-end;
   gap: 10px;
 }

 .post .social-item {
   display: flex;
   align-items: center;
   gap: 3px;
   font-size: 12px;
   color: #888;
 }
 
 /* Add styles for the static posts */
 .static {
   border: 2px solid lightgray !important; 
   opacity: 0.85; /* You can adjust the opacity to your preference */
 }

 /* Add styles for the draggable posts */
 .post:not(.static) {
   z-index: 9999;
   border: 3px solid rgb(182, 211, 229) !important;
   cursor: grab;
 }
 
 /* When dragging, change the cursor to grabbing */
 .post:not(.static).ui-sortable-helper {
   cursor: grabbing;
 }

 ul li,
ol li {
  list-style: none;
  margin: 0;
  padding: 0;
}
 
 /* Style for the feed list bank */
 .feed-list-bank {
   background-color: #f9f9f9;
   border: 1px solid #ccc;

   padding-top: 2px;
   padding-left: 10px;
   padding-bottom: 10px;
   padding-right: 10px;

   margin: 2;

   border-radius: 5px;
   min-height: 100px;
 }

</style>   
</head>

<body>

  <div class='container-fluid px-1'>
    <div class="container-fluid mt-0 text-white fixed-top" id="top-bar">
  <div class="d-flex justify-content-between py-2 px-4">
    <h3 id="screen-title" class="m-0">Screen Title</h3>
    <div id="question-progress" class="m-2">
    </div>
  </div>
</div>
    <div class='row p-2' id='introduction' style="display:none;">
    <div class='col-12'>
        <div class="card pb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-6">
                        <p style="font-size: 18px;"><b>If an equation isn't showing correctly, refresh the page.</b></p>
                        <p style="font-size: 18px;">
						In the upcoming questions, you'll be presented with a feed sorted by a feed ranking algorithm. 
						Then, you'll answer questions about the algorithm that ranked the feed. 
						</p>
						<p style="font-size: 18px;">A feed algorithm sorts posts by giving each one a score and placing 
						the posts with the highest scores at the top. For example, if an algorithm assigns scores according to posts'
						<i>"Hours Since Posted"</i> older posts would have a higher score and appear at the top of the feed.</p>
						<p style="font-size: 18px;">
						You will receive <b>$0.15 for each correct answer</b>. After each question, you will also be asked 
						to assess how confident you are in your answer. Correct self-assessment 
						will be bonused up to $0.06. The first section will serve as practice. </p>
						
						<p> <b>Click next (or press enter) to start.</b></p>
                    </div>
                    <div class="col-6" style="border: 1px solid #ccc; padding: 10px; margin-bottom: 50px;">
                        <img src="./templates/reference_post.png">
                        <p><i>Example post with highlighted parts.</i></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <div class='row p-2' id='submission' style="display:none;">
	<div class='col-12'>
		<div class="card">
			<div class="card-body">
				<p>Thank you for completing our entire study! 	
				Please <strong>click submit.</strong> It may take a moment to redirect you.</p>
				<button type="button" class="btn btn-primary" id='submit-btn-1' onclick="submit()">Submit</button>
				</form>
			</div>
		</div>
	</div>
</div>
    <div class="container-fluid p-0" id="left-feed-questions" class="screen" style="display:none;">
	<div class="row justify-content-center">
	  <div class="feed-container" id="LFQ-feed-container">
		<div class="col-md-12 p-0" id="LFQ-feeds">
		</div>
	  </div>
	  <div class="question-container px-md-3 py-md-3" id="LFQ-questions-container">
	  </div>
	</div>
  </div>
    <div class="container-fluid mt-0" id="bottom-bar" style="display:block;">
  <div class="d-flex justify-content-end">
	<button type="button" class="btn btn-primary" id="next-btn" onclick="next_screen()">Next</button>
  </div>
  <script>
    // Get the button element by its id
    var nextButton = document.getElementById("next-btn");

    // Function to simulate button click when Enter key is pressed
    function activateNextButton(event) {
        if (event.key === "Enter") {
            nextButton.click();
        }
    }

    // Add an event listener to the document to capture key presses
    document.addEventListener("keydown", activateNextButton);
</script>

</div>
  
  </div>
  <script type='text/json' id='input'>
  
</script>
<!-- MATT: Do we need this button? -->
<!-- <form id='results-form' method='post' action='dummy' class='text-center'>
  <input type='hidden' value='' name='assignmentId' id='assignmentId'/>
  <input type='hidden' value='' name='output' id='output'/>
  <input type='submit' class='btn btn-lg btn-success' id='submit-btn' value='Submit' disabled/>          
</form> -->
<script>
  var easyturk = (function() {
    
    // Copied from http://james.padolsey.com/javascript/bujs-1-getparameterbyname/
    function getUrlParam(name) {
      var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
      return match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : null;
    }

    function getInput(default_input) {
      if (typeof(default_input) === 'undefined') default_input = null;
      try {
        return JSON.parse($('#input').html());
      } catch (e) {
        return default_input;
      }
    }

    function setOutput(output) {
      $('#output').val(JSON.stringify(output));
    }

    function isPreview() {
      return false;
      var assignment_id = getUrlParam('assignmentId');
      if (assignment_id === null) return false;
      return assignment_id == 'ASSIGNMENT_ID_NOT_AVAILABLE';
    }

    function setupSubmit() {
      var submit_to = getUrlParam('turkSubmitTo');
      $('#results-form').attr('action', submit_to + '/mturk/externalSubmit');                      
      $('#assignmentId').val(getUrlParam('assignmentId'));
    }

    return {
      getInput: getInput,
      setOutput: setOutput,
      isPreview: isPreview,
      setupSubmit: setupSubmit,
    }

  })();
</script>
  <script type="text/javascript">

function array_to_string(array) {
  return array.join(', ');
}

function parseTextFile() {
    const data = reddit_data;

    const lines = data.trim().split('\n');
    const result = [];

    for (const line of lines) {
      const [submissionId, subreddit, title, author, comments, nsfw, score, upvoted, link, content] = line.split('\t');
      const dictionary = {
        "SUBMISSION_ID": submissionId,
        "SUBREDDIT": subreddit,
        "TITLE": title,
        "AUTHOR": author,
        "#_COMMENTS": parseInt(comments),
        "NSFW": nsfw === 'NSFW',
        "SCORE": parseInt(score),
        "UPVOTED_%": parseFloat(upvoted),
        "LINK": link,
      };
      result.push(dictionary);
    }

    return result;
}

function merge_objects(obj1, obj2) {
  const result = {};
  for (const key in obj1) {
    result[key] = obj1[key];
  }
  for (const key in obj2) {
    result[key] = obj2[key];
  }
  return result;
}

function shuffle_array(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// truncates a number to two decimal points
function truncate(number) {
  return Math.round(number * 10) / 10;
}

function shallowCopy(obj) {
  if (Array.isArray(obj)) {
    return obj.map(item => shallowCopy(item));
  } else if (typeof obj === 'object' && obj !== null) {
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, shallowCopy(value)]));
  }
  return obj;
}

function string_to_rgb(string) {
  // Simple hash function to convert the string to a numeric value
  function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return hash;
  }

  // Convert the hash value to RGB values within the range [0, 255]
  function intToRGB(i) {
    const c = (i & 0x00FFFFFF).toString(16).toUpperCase();
    return "00000".substring(0, 6 - c.length) + c;
  }

  // Generate a numeric hash value from the input string
  const hashValue = hashString(string);

  // Convert the hash value to RGB values
  const rgbString = intToRGB(hashValue);

  // Extract the RGB values and convert them to an array
  const r = parseInt(rgbString.slice(0, 2), 16);
  const g = parseInt(rgbString.slice(2, 4), 16);
  const b = parseInt(rgbString.slice(4, 6), 16);

  return [r, g, b];
}

function generate_ranking_text(weights, show_zeroes = false) {
  let text = `$$\\begin{align*}`;

  let sumOfAbsoluteWeights = 0;
  let num_weights_nonzero = 0;
  
  // Calculate sum of absolute weights and count nonzero weights
  for (const key in weights) {
    if (Math.abs(weights[key]) > 0) {
      sumOfAbsoluteWeights += Math.abs(weights[key]);
      num_weights_nonzero++;
    }
  }
  
  // Calculate scaling factor to achieve a total of 100
  const scalingFactor = 100 / sumOfAbsoluteWeights;

  for (const key in weights) {
    if (weights[key] !== 0 || show_zeroes) {
      const scaledWeight = weights[key] * scalingFactor;
      const roundedWeight = Math.abs(scaledWeight.toFixed(0));
      const sign = scaledWeight >= 0 ? " + " : " - ";
      text += `&${num_weights_nonzero > 1 || scaledWeight < 0 ? sign : ''}${num_weights_nonzero > 1 ? roundedWeight + '\\% \\times' : ''} \\text{${feature_dict[key]}} \\\\`;
    }
  }

  text += "\\end{align*} $$";

  return text;
}

function generate_study_array(studies, feature_counts, num_repeats, template, feature_keys, num_posts, includes_practice) {
  const screen_array = [];

  // Introduction screen
  const introduction_screen = {
    'type': "introduction",
    'template': "introduction",
  };
  screen_array.push([introduction_screen]);

  // Shuffle studies and posts
  const shuffledStudies = shallowCopy(studies);
  shuffle_array(shuffledStudies);
  shuffle_array(json_posts["posts"]);

  let practice_array = [];

  // generate practice screen for each study (with one feature)
  if (includes_practice) {
    for (const studyType of shuffledStudies) {
      const weights = generate_weights(feature_keys, 1);
      
      if (studyType == 'feed-selection') {
        const studyObj = generateFeedSelectionStudy(studyType, template, 4, weights, 1, 0, true);
        practice_array.push(studyObj);
      }

      if (studyType == 'feed-comparison-B') {
        const studyObj = generateFeedComparisonStudy(studyType, template, 4, weights, 1, 0, true);
        practice_array.push(studyObj);
      }

      if (studyType == 'post-placement') {
        const studyObj = generatePostPlacementStudy(studyType, template, 4, weights, 1, 0, true);
        practice_array.push(studyObj);
      }

      if (studyType == 'feature-selection') {
        const studyObj = generateFeatureSelectionStudy(studyType, template, 4, weights, 1, 0, true);
        practice_array.push(studyObj);
      }
      
    }

    screen_array.push(practice_array);
  }

  let study_array = [];

  // Generate study objects
  for (const studyType of shuffledStudies) {
    for (let repeatNum = 1; repeatNum <= num_repeats; repeatNum++) {
      for (const featureCount of feature_counts) {
        const weights = generate_weights(feature_keys, featureCount);

        if (studyType == 'feed-selection') {
          const studyObj = generateFeedSelectionStudy(studyType, template, num_posts, weights, featureCount, repeatNum);
          study_array.push(studyObj);
        }

        if (studyType == 'feed-comparison-B') {
          const studyObj = generateFeedComparisonStudy(studyType, template, num_posts, weights, featureCount, repeatNum);
          study_array.push(studyObj);
        }

        if (studyType == 'post-placement') {
          const studyObj = generatePostPlacementStudy(studyType, template, num_posts, weights, featureCount, repeatNum);
          study_array.push(studyObj);
        }

        if (studyType == 'feature-selection') {
          const studyObj = generateFeatureSelectionStudy(studyType, template, num_posts, weights, featureCount, repeatNum);
          study_array.push(studyObj);
        }

      }
    }

    insertDuplicateStudy(study_array, num_repeats, feature_counts.length);
  }

  screen_array.push(study_array);

  // Submission screen
  const submission_screen = {
    'type': "submission",
    'template': "submission",
  };
  screen_array.push([submission_screen]);

  return screen_array;
}

// Generate a feed-selection study object
function generateFeedSelectionStudy(studyType, template, num_posts, weights, feature_count, repeatNum, is_practice = false) {
  const studyObj = {
    'study_type': studyType,
    'feature_count': feature_count,
    'instance_number': repeatNum,
    'type': is_practice ? "practice" : "study",
    'template': template,
    'feeds': [json_posts["posts"].splice(0, num_posts)],
    'weights': weights,
  };

  linear_combination_sort(studyObj['feeds'][0], weights);

  if (studyObj['study_type'].startsWith('feed-selection')) {
    studyObj['feeds'].push(shallowCopy(studyObj['feeds'][0]));
    const correct_feed_index = Math.random() > 0.5 ? 0 : 1;
    const incorrect_feed_index = correct_feed_index == 0 ? 1 : 0;
    studyObj['correct_feed_index'] = correct_feed_index;
    shuffle_array(studyObj['feeds'][incorrect_feed_index]);
  }

  return studyObj;
}

// Generate a feed-comparison study object
function generateFeedComparisonStudy(studyType, template, num_posts, weights, feature_count, repeatNum, is_practice = false) {
  const studyObj = {
    'study_type': studyType,
    'feature_count': feature_count,
    'instance_number': repeatNum,
    'type': is_practice ? "practice" : "study",
    'template': template,
    'feeds': [
      json_posts["posts"].splice(0, num_posts),
      json_posts["posts"].splice(0, num_posts)
    ],
    'weights': weights,
  };

  linear_combination_sort(studyObj['feeds'][0], weights);
  linear_combination_sort(studyObj['feeds'][1], weights);

  const same_sort_B = JSON.stringify(studyObj['feeds'][1]);
  let permuted = Math.random() > 0.5;
  let permuted_weights = shallowCopy(weights);

  if (permuted) {
    do {
      permute_weights_valence(permuted_weights);
      linear_combination_sort(studyObj['feeds'][1], permuted_weights);
    } while (JSON.stringify(studyObj['feeds'][1]) == same_sort_B);
  }

  studyObj['permuted'] = permuted;
  studyObj['permuted_weights'] = permuted_weights;

  return studyObj;
}

// Generate a post-placement study object
function generatePostPlacementStudy(studyType, template, num_posts, weights, feature_count, repeatNum, is_practice = false) {
  const studyObj = {
    'study_type': studyType,
    'feature_count': feature_count,
    'instance_number': repeatNum,
    'type': is_practice ? "practice" : "study",
    'template': template,
    'feeds': [json_posts["posts"].splice(0, num_posts)],
    'weights': weights,
    'correct_position': Math.floor(Math.random() * num_posts),
  };

  linear_combination_sort(studyObj['feeds'][0], weights);

  return studyObj;
}

function generateFeatureSelectionStudy(studyType, template, num_posts, weights, feature_count, repeatNum, is_practice = false) {
  const studyObj = {
    'study_type': studyType,
    'feature_count': feature_count,
    'instance_number': repeatNum,
    'type': is_practice ? "practice" : "study",
    'template': template,
    'feeds': [json_posts["posts"].splice(0, num_posts)],
    'weights': weights,
  };

  linear_combination_sort(studyObj['feeds'][0], weights);

  return studyObj;
}

// Insert duplicate study for source study type
function insertDuplicateStudy(screen_array, num_repeats, num_feature_counts) {
  const source_index = screen_array.length - (num_repeats * num_feature_counts);
  const studyObj = shallowCopy(screen_array[source_index]);
  const random_index = source_index + 3 + Math.floor(Math.random() * ((num_repeats * num_feature_counts) - 3));
  screen_array.splice(random_index, 0, studyObj);
}

function generate_screen_name(screen_info) {
  let screen_name = `study-${screen_info["study_type"]}-features-${screen_info["feature_count"]}-${screen_info["instance_number"]}`;
  if (screen_info.type == 'introduction') {
    screen_name = 'introduction';
  } else if (screen_info.type == 'submission') {
    screen_name = 'submission';
  }
  return screen_name;
}

function get_questions(screen_type, confidence = true) {
  const questions = {};
  for (let i = 0; i < json_questions[screen_type].length; i++) {
    questions[`Q${i+1}`] = json_questions[screen_type][i];
  }

  if (confidence) {
    questions[`CF`] = json_questions["confidence"][0];
    questions[`CF`]['text'] = json_questions["confidence-texts"][screen_type];
  }
  
  return questions;
}

</script>

  <script type="text/javascript" src="templates/data/feed_data.json"></script>
  <script type="text/javascript" src="templates/data/question_data.json"></script>

  <script type="text/javascript">

function insert_label(labelText, labelContainer, label_width) {
  const label_div = document.createElement("div");
  label_div.className = `col-${label_width} d-flex align-items-center justify-content-center`; // Added justify-content-center
  label_div.innerHTML = 
  `<div class="feed-label pt-2">
    <span class="font-weight-bold h2">${labelText}</span>
  </div>`;
  labelContainer.appendChild(label_div);
}

function insert_feed(feed_data, container, feed_width, locked) {
  const feedBankContainer = document.createElement("div");
  feedBankContainer.className = `col-md-${feed_width} p-md-1`;

  const feedParentUl = document.createElement("ul");
  feedParentUl.className = `feed sortable${locked ? ' locked' : ''} feed-list-bank list-unstyled`;

  feed_data.forEach(post => {
    insert_post(post, feedParentUl, locked);
  });

  feedBankContainer.appendChild(feedParentUl);

  container.appendChild(feedBankContainer);

  $('.sortable').sortable({
    connectWith: '.sortable',
    cancel: '.static',
    scroll: false,
    zIndex: 9999,
    appendTo: $('.feed').not('.locked'),
  });
}

function insert_post(post, feed_parent_list, locked) {
  const postListItem = document.createElement("li");
  postListItem.className = `bg-white border mt-2 post${locked ? ' static' : ''} rounded`;
  let rgb = string_to_rgb(post.author_name);

  postListItem.innerHTML = `
    <div class="d-flex flex-row justify-content-between align-items-center p-1 border-bottom">
      <div class="d-flex flex-row align-items-center feed-text px-2">
        <div style="width: 40px; height: 40px; border-radius: 50%; background-color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]});"></div>
        <div class="d-flex flex-column flex-wrap ml-2">
          <span class="font-weight-bold">${post.author_name}</span>
          <span class="small-text">${post.days_since_posted} hour${post.days_since_posted != 1 ? "s" : ""} ago</span>
        </div>
      </div>
      <div class="feed-icon px-2"><i class="fa fa-ellipsis-v text-black-50"></i></div>
    </div>
    <div class="p-1 px-1">
      <span class="small-text">${post.text}</span>
    </div>
    <div class="d-flex justify-content-between p-1 py-1">
      <div class="character-count p-1 px-1">
        <span class="xs-text">${post.text.length} characters</span>
      </div>
      <div class="socials d-flex justify-content-end socials">
        <div class="social-item">
          <i class="fa fa-thumbs-up"></i>
          <span class="count">${post.like_count}</span>
        </div>
        <div class="social-item">
          <i class="fa fa-comments-o"></i>
          <span class="count">${post.comment_count}</span>
        </div>
        <div class="social-item">
          <i class="fa fa-eye"></i>
          <span class="count">${post.view_count}</span>
        </div>
      </div>
    </div>
  `;

  postListItem.setAttribute("data-number", post.correct_position ?? -1);

  feed_parent_list.appendChild(postListItem);
}

function populate_feed_container(feeds, container, labeled) {
  const feed_width = Math.floor(12 / feeds.length);
  const label_width = feed_width;

  const labelRow = document.createElement("div");
  labelRow.className = "row label-container align-items-start pl-1 pr-3 pb-1";
  container.appendChild(labelRow);

  const feedRow = document.createElement("div");
  feedRow.className = "row feed-scroll visible-scrollbar";
  container.appendChild(feedRow);

  for (let i = 0; i < feeds.length; i++) {
    if (labeled) {
      let labelText = String.fromCharCode(65 + i);
      insert_label(labelText, labelRow, label_width);
    }

    insert_feed(feeds[i], feedRow, feed_width, true);
  }
}

function insert_reddit_post(post, feed_parent_list) {
  const postListItem = document.createElement("div");
  postListItem.className = "bg-white border mt-2 post rounded p-2";

  postListItem.innerHTML = `
    <div class="d-flex justify-content-between align-items-center border-bottom mb-2">
      <span class="font-weight-bold">${"r/" + post.SUBREDDIT}</span>
      <div class="feed-icon"><i class="fa fa-ellipsis-v text-black-50"></i></div>
    </div>
    <div>
      <span class="fs-5">${post.TITLE}</span>
    </div>
    <div class="d-flex justify-content-between align-items-center mt-2">
      <div class="d-flex">
        <div class="small-text mr-2">
          <i class="fa fa-thumbs-up"></i>
          <span class="count">${post.SCORE}</span>
        </div>
        <div class="small-text">
          <i class="fa fa-comments-o"></i>
          <span class="count">${post["#_COMMENTS"]}</span>
        </div>
      </div>
      <div class="small-text">
        ${(post["UPVOTED_%"] * 100).toFixed(0)}% upvoted
      </div>
    </div>
  `;

  feed_parent_list.appendChild(postListItem);
}

function insert_text(question_text, container) {
  const question_div = document.createElement("div");
  question_div.className = "pr-3";

  const question_element = document.createElement("p");
  question_element.className = "small-text font-weight-bold mb-0";
  question_element.innerHTML = question_text;
  question_div.appendChild(question_element);

  container.appendChild(question_div);
}
function insert_mcq(question, container, screen_name, question_name) {
  const question_div = document.createElement("div");
  question_div.className = "study-question mb-2 mr-3 rounded";
  question_div.id = `${screen_name}-${question_name}`;

  insert_text(question.text, question_div);

  for (let i = 0; i < question.options.length; i++) {
    const radio_div = document.createElement("div");
    const radio_input = document.createElement("input");
    const radio_label = document.createElement("label");

    radio_div.className = "form-check mt-2";
    radio_input.className = "form-check-input";
    radio_label.className = "form-check-label";
    radio_label.style.display = "inline-block";
    radio_label.style.paddingLeft = "25px";
    radio_label.style.marginLeft = "-25px";

    radio_input.type = "radio";
    radio_input.name = `question_${container.id}_${question_name}`;
    radio_input.value = question["option-key"][i];
    radio_input.id = `${container.id}_${question.options[i].replace(/\s+/g, "_").toLowerCase()}`;

    radio_label.for = radio_input.id;
    radio_label.textContent = question.options[i];

    radio_div.appendChild(radio_input);
    radio_div.appendChild(radio_label);

    question_div.appendChild(radio_div);

    radio_label.addEventListener("click", () => {
      radio_input.checked = true;
    });
  }

  container.appendChild(question_div);
}

function insert_radio_buttons(question, container, screen_name, question_name) {
  const question_div = document.createElement("div");
  question_div.className = "study-question pl-2 mb-2 mr-3 rounded";
  question_div.id = `${screen_name}-${question_name}`;

  insert_text(question.text, question_div);

  const radioButtonsRow = document.createElement("div");
  radioButtonsRow.className = "radio-buttons-row mt-2";
  radioButtonsRow.style.display = "flex";
  radioButtonsRow.style.justifyContent = "between"

  question_div.appendChild(radioButtonsRow);

  let selectedButton = null;

  const availableWidth = container.offsetWidth / question.options.length;
  
  const min_length = question.options.reduce((min, current) => {
    return current.length < min ? current.length : min;
  }, question.options[0].length);

  for (let i = 0; i < question.options.length; i++) {
    const radio_button = document.createElement("button");

    radio_button.className = "btn btn-outline-primary mr-1 pt-2 d-flex justify-content-center align-items-center";
    radio_button.type = "button";

    const adjustedWidth = availableWidth * 0.9;
    radio_button.style.width = `${adjustedWidth}px`;

    radio_button.style.width = `${90 / question.options.length}%`;

    radio_button.addEventListener("click", () => {
      const selectedRadio = radio_button.querySelector("input[type='radio']");
      selectedRadio.checked = true;

      if (selectedButton) {
        selectedButton.classList.remove("btn-primary");
        selectedButton.querySelector("label").classList.remove("selected-label");
      }

      radio_button.classList.add("btn-primary");
      selectedButton = radio_button;
      selectedButton.querySelector("label").classList.add("selected-label"); 

      radio_button.blur();
    });

    const radio_input = document.createElement("input");
    radio_input.type = "radio";
    radio_input.name = `question_${container.id}_${question_name}`;
    radio_input.value = question['option-key'][i];
    radio_input.id = `${container.id}_${question.options[i].replace(/\s+/g, "_")}`.toLowerCase();
    radio_input.style.display = "none";

    const radio_label = document.createElement("label");
    radio_label.for = radio_input.id;
    radio_label.textContent = question.options[i];

    const maxFontSize = (100 *  Math.sqrt(questions_column_width)) / min_length;

    radio_label.style.fontSize = `${maxFontSize}px`;

    radio_label.classList.add("d-flex", "justify-content-center", "align-items-center");

    radio_button.appendChild(radio_input);
    radio_button.appendChild(radio_label);
    radioButtonsRow.appendChild(radio_button);
  }

  container.appendChild(question_div);
}

function insert_checkbox(question, container, screen_name, question_name) {
  const question_div = document.createElement("div");
  question_div.className = "study-question mb-4 rounded"; 
  question_div.id = `${screen_name}-${question_name}`;
  
  insert_text(question.text, question_div);

  for (let i = 0; i < question.options.length; i++) {
    const checkbox_div = document.createElement("div");
    const checkbox_input = document.createElement("input");
    const checkbox_label = document.createElement("label");

    checkbox_div.className = "form-check mt-2"; 
    checkbox_input.className = "form-check-input";
    checkbox_label.className = "form-check-label";

    checkbox_input.type = "checkbox";
    checkbox_input.name = `question_${container.id}`;
    checkbox_input.value = question['option-key'][i];
    checkbox_input.id = `${container.id}_${question.options[i].replace(/\s+/g, "_").toLowerCase()}`;

    checkbox_label.for = checkbox_input.id;
    checkbox_label.textContent = question.options[i];
    
    checkbox_div.appendChild(checkbox_input);
    checkbox_div.appendChild(checkbox_label);
    question_div.appendChild(checkbox_div);
  }
  
  container.appendChild(question_div);
}

function insert_post_placement(question, container, screen_name, question_name) {
  const question_div = document.createElement("div");
  question_div.className = "post-placement-question mb-3 mr-3 rounded";
  question_div.id = `${screen_name}-${question_name}`;

  insert_text(question.text, question_div);

  container.appendChild(question_div);

  insert_feed(question['feed'], question_div, 12, false);
}

function insert_radio_grid(question, container, screen_name, question_name) {
  const question_div = document.createElement("div");
  question_div.className = "study-question mb-4";
  question_div.id = `${screen_name}-${question_name}`;

  insert_text(question.text, question_div);

  const gridDiv = document.createElement("div");
  gridDiv.className = "radio-grid";

  for (let i = 0; i < question.entries.length; i++) {
    const entryDiv = document.createElement("div");
    entryDiv.className = "radio-grid-row row mb-2";

    const entryLabel = document.createElement("div");
    entryLabel.className = "col-md-3 radio-grid-entry";
    entryLabel.textContent = question.entries[i];
    entryDiv.appendChild(entryLabel);

    const optionDiv = document.createElement("div");
    optionDiv.className = "col-md-9 radio-grid-options";

    for (let j = 0; j < question.options.length; j++) {
      const radio_input = document.createElement("input");
      const radio_label = document.createElement("label");

      radio_input.className = "form-check-input";
      radio_label.className = "form-check-label";

      radio_input.type = "radio";
      radio_input.name = `question_${container.id}_${i}`;
      radio_input.value = question['option-key'][i][j];
      radio_input.id = `${container.id}_${question.entries[i]}_${question.options[j].replace(/\s+/g, "_").toLowerCase()}`;
      radio_input.setAttribute("data-entry", i);

      radio_label.for = radio_input.id;
      radio_label.textContent = question.options[j];

      optionDiv.appendChild(radio_input);
      optionDiv.appendChild(radio_label);
    }

    entryDiv.appendChild(optionDiv);
    gridDiv.appendChild(entryDiv);
  }

  question_div.appendChild(gridDiv);
  container.appendChild(question_div);
}

function populate_questions_container(questions, container, screen_name) {

  for (let question_name in questions) {
    let question = questions[question_name];

    if (question['type'] == 'checkbox') {
      insert_checkbox(question, container, screen_name, question_name);
    } else if (question['type'] == 'multiple-choice') {
      insert_mcq(question, container, screen_name, question_name);
    } else if (question['type'] == 'post-placement') {
      insert_post_placement(question, container, screen_name, question_name);
    } else if (question['type'] == 'radio-buttons') {
      insert_radio_buttons(question, container, screen_name, question_name);
    } else if (question['type'] == 'radio-grid') {
      insert_radio_grid(question, container, screen_name, question_name);
    } else {
      console.log('unknown question type');
    }
  }
}

</script>
  <script type="text/javascript">

function populate_LFQ(screen_info, screen_name) {
  $('#LFQ-feeds').empty();
  $('#LFQ-questions-container').empty();

  const screen_type = screen_info["study_type"];
  const questions = get_questions(screen_type, screen_info['type'] != 'practice');
  const num_feeds =  screen_info['feeds'].length;

  let feeds = shallowCopy(screen_info['feeds']);

  const unit_width = Math.min(12 / (num_feeds + 1), num_feeds * 5);

  const feed_column_width = Math.floor(unit_width * num_feeds);
  questions_column_width = Math.ceil(unit_width);

  $('#LFQ-feed-container').removeClass(function (index, className) {
    return (className.match(/\bcol-md-\S+/g) || []).join(' ');
  }).addClass(`col-md-${feed_column_width}`);
  
  $('#LFQ-questions-container').removeClass(function (index, className) {
    return (className.match(/\bcol-md-\S+/g) || []).join(' ');
  }).addClass(`col-md-${questions_column_width}`);

  let text = "";
  let labeled = false;
  let weights = screen_info['weights'];

  if (screen_type == "feed-selection") {
    // text = `An algorithm ranks posts based on the following criteria:`;
    labeled = true;
    let correct_feed_idx = screen_info['correct_feed_index'];

    questions['Q1']['options'] = Array.from({ length: feeds.length }, (value, index) => ("Feed " + String.fromCharCode(65 + index)));
    questions['Q1']['option-key'] = Array.from({ length: feeds.length }, (value, index) => index === correct_feed_idx ? 1 : 0);
  
  } else if (screen_type == "feature-selection") {
    labeled = false;
    linear_combination_sort(feeds[0], weights);

    const score_per_option = 1 / feature_names.length;
    questions['Q1']['options'] = feature_names;
    questions['Q1']['option-key'] = Array.from({ length: feature_keys.length }, (value, index) => weights[feature_keys[index]] != 0 ? score_per_option : -score_per_option);
  } else if (screen_type == "post-placement") {
    // text = `This feed's algorithm ranks posts based on the following criteria:`;
    labeled = false;
    let randomIndex = screen_info['correct_position'];
    let extractedPost = feeds[0][randomIndex];
    extractedPost['correct_position'] = randomIndex;
    
    let question_feed = [extractedPost];
    
    feeds[0].splice(randomIndex, 1);
    
    questions['Q1']['feed'] = question_feed;
  } else if (screen_type == "feed-comparison") {
    text = `Feed A was sorted using the following scoring:`;
    labeled = true;

    let original_weights = shallowCopy(weights);

    linear_combination_sort(feeds[0], weights);
    let permuted_feature, permuted_weights;

    do {
      permuted_weights = shallowCopy(weights);
      permuted_feature = permute_weights(permuted_weights);
      linear_combination_sort(feeds[1], permuted_weights);
    } while (JSON.stringify(feeds[0]) == JSON.stringify(feeds[1]));

    let change_direction = permuted_weights[permuted_feature] > original_weights[permuted_feature] ? 1 : -1;

    let feature_options = shallowCopy(feature_names);
    shuffle_array(feature_options);
    questions['Q1']['options'] = feature_options;
    questions['Q1']['option-key'] = Array.from({ length: feature_keys.length }, (value, index) => index === feature_keys.indexOf(feature_options[permuted_feature]) ? 1 : 0);

    questions['Q2']['option-key'] = change_direction > 0 ? [1, 0] : [0, 1];
  } else if (screen_type == "feed-comparison-B") {
    //text = `Feed A's algorithm ranks posts based on the following criteria:`;
    labeled = true;

    questions['Q1']['options'] = questions['Q1']['options'];
    questions['Q1']['option-key'] = screen_info['permuted'] ? [1, 0] : [0, 1];
  }

  // text += generate_ranking_text(weights, screen_type == "feed-comparison");
  insert_text(text, document.getElementById('LFQ-questions-container'));

  populate_feed_container(feeds, document.getElementById('LFQ-feeds'), labeled);
  populate_questions_container(questions, document.getElementById('LFQ-questions-container'), screen_name);
}

</script>
  <script type="text/javascript">

function highlight_unanswered_questions(unanswered_questions, incorrect_questions) {
  const question_divs = $(".study-question, .post-placement-question");
  
  question_divs.each((i, question_div) => {
    if (unanswered_questions[question_div.id]) {
      question_div.setAttribute('data-state', 'unanswered');
      question_div.style.border = "2px solid red";
      displayMessage(question_div, "red", "Please answer the required question.");
    } else if (incorrect_questions[question_div.id]) {
      question_div.setAttribute('data-state', 'incorrect');
      question_div.style.border = "2px solid orange";
      displayMessage(question_div, "orange", answer_to_feedback(incorrect_questions[question_div.id]));
    } else {
      question_div.removeAttribute('data-state');
      question_div.style.border = "";
      removeMessage(question_div);
    }
  });
}

function answer_to_feedback(answer) {
  if (answer.question_type == "multiple-choice") {
    return `Your answer of "<strong>${array_to_string(answer.chosen_answers)}</strong>" was incorrect. The correct answer was "<strong>${array_to_string(answer.correct_answers)}</strong>". 
            Please correct your answer and try a new version of this question in the next screen.`;
  }
  
  if (answer.question_type == "post-placement") {
    return `Your placement of the post at position <strong>${answer.chosen_answers[0] + 1}</strong> is incorrect. Its correct position is <strong>${answer.correct_answers[0] + 1}</strong>.
            Please correct your answer and try a new version of this question in the next screen.`;
  }
}

function displayMessage(question_div, color, message) {
  removeMessage(question_div);

  const message_div = document.createElement("div");
  message_div.className = "message py-2";
  message_div.style.color = color;
  message_div.style.fontSize = "medium";
  message_div.style.textAlign = "center";
  message_div.innerHTML = message;
  question_div.appendChild(message_div);
}

function removeMessage(question_div) {
  const message_div = question_div.querySelector('.message');
  if (message_div) {
    question_div.removeChild(message_div);
  }
}


/**
 * Processes a checked question and updates the screen output.
 * @param {Element} questionDiv - The question div element.
 * @param {Object} screenOutput - The screen output object.
 * @param {Array} unansweredQuestions - Array to track unanswered questions.
 */
 function process_check_question(questionDiv, screenOutput, unanswered_questions, incorrect_questions) {
  const questionId = questionDiv.id;
  const inputs = questionDiv.querySelectorAll("input");
  const checked_inputs = questionDiv.querySelectorAll("input:checked");
  const unchecked_inputs = questionDiv.querySelectorAll("input:not(:checked)");

  const checkedOptions = [];
  const correct_answers = [];
  let sumOfValues = 0;

  for (let j = 0; j < checked_inputs.length; j++) {
    const checkedInput = checked_inputs[j];
    const optionText = checkedInput.nextElementSibling.textContent;
    checkedOptions.push(optionText);
    const optionValue = parseFloat(checkedInput.value, 10);
    sumOfValues += isNaN(optionValue) ? 0 : optionValue < 0 ? 0 : optionValue;
  }

  if (questionId.slice(-2) !== "CF") {
    // loop over the inouts that are not checked
    for (let j = 0; j < unchecked_inputs.length; j++) {
      const uncheckedInput = unchecked_inputs[j];
      const optionText = uncheckedInput.nextElementSibling.textContent;
      const optionValue = parseFloat(uncheckedInput.value, 10);
      sumOfValues += isNaN(optionValue) ? 0 : optionValue < 0 ? -optionValue : 0;
    }
  }

  for (let j = 0; j < inputs.length; j++) {
    const input = inputs[j];
    const optionText = input.nextElementSibling.textContent;
    const optionValue = parseFloat(input.value, 10);

    console.log(optionText, optionValue);
    if (optionValue > 0) {
      correct_answers.push(optionText);
    }

  }

  const question = {
    "question_type": "multiple-choice",
    "correct_answers": correct_answers,
    "chosen_answers": checkedOptions
  };

  console.log(question);

  if (checkedOptions.length === 0) {
    unanswered_questions[questionDiv.id] = question;
  } else if (checkedOptions.length !== correct_answers.length || !checkedOptions.every((value, index) => value === correct_answers[index])) {
    incorrect_questions[questionDiv.id] = question;
  }

  if (questionId.slice(-2) === "CF") {
    screenOutput["chosen_confidence"] = checkedOptions[0];
    screenOutput["confidence"] = sumOfValues;
  } else {
    const questionNum = questionId.slice(-2);
    screenOutput["chosen_options_" + questionNum] = checkedOptions;
    screenOutput["score_" + questionNum] = sumOfValues;
  }
}

/**
 * Processes a post placement question and updates the screen output.
 * @param {Element} questionDiv - The question div element.
 * @param {Object} screenOutput - The screen output object.
 * @param {Array} unansweredQuestions - Array to track unanswered questions.
 * @param {Element} feed - The feed element.
 */
 function process_post_placement_question(questionDiv, screenOutput, unanswered_questions, incorrect_questions, feed) {
  const posts = feed.querySelectorAll('li');

  let chosenIndex = -1;
  let correctIndex = -1;
  let distance = -1;

  for (let i = 0; i < posts.length; i++) {
    const post = posts[i];
    const position = parseInt(post.dataset.number);
    if (position >= 0) {
      distance = Math.abs(i - position);
      correctIndex = position;
      chosenIndex = i;
      break;
    }
  }

  const question = {
    "question_type": "post-placement",
    "correct_answers": [correctIndex],
    "chosen_answers": [chosenIndex],
  };

  if (chosenIndex === -1) {
    unanswered_questions[questionDiv.id] = question;
  } else if (distance > 0) {
    incorrect_questions[questionDiv.id] = question;
  }

  screenOutput["chosen_index"] = chosenIndex;
  screenOutput["correct_index"] = correctIndex;
  screenOutput["distance"] = distance;
  screenOutput["score_Q1"] = distance === 0 ? 1 : 0;
}

/**
 * Logs checked answers with sum and updates the screen output.
 * @param {string} screenName - The screen name.
 * @returns {Array} - Array of unanswered question div elements.
 */
function log_checked_answers_with_sum(screen_info, screenName) {
  const studyQuestions = document.getElementsByClassName("study-question");
  const postPlacementQuestions = document.getElementsByClassName("post-placement-question");
  const feedElements = document.querySelectorAll('.feed');
  const screenOutput = 
  {
    "study_type": screen_info.study_type,
    "feature_count": screen_info.feature_count,
    "instance_number": screen_info.instance_number,
    "screen_name": screenName,
    };

  const unanswered_questions = {};
  const incorrect_questions = {};
  const is_practice = screen_info.type == "practice";

  for (let i = 0; i < studyQuestions.length; i++) {
    process_check_question(studyQuestions[i], screenOutput, unanswered_questions, incorrect_questions);
  }

  for (let i = 0; i < postPlacementQuestions.length; i++) {
    process_post_placement_question(postPlacementQuestions[i], screenOutput, unanswered_questions, incorrect_questions, feedElements[i]);
  }

  if (Object.keys(unanswered_questions).length === 0) {
    screenOutput['time-elapsed'] = (new Date().getTime() - start_times[screenName]) / 1000;

    if (!output["questions"]) {
      output["questions"] = [];
    }

    if (is_practice) {
      screenOutput["screen_name"] = screenName + "-PRACTICE";
      screenOutput["practice"] = true;

      const screenOutputWithSameName = output["questions"].find(output => output["screen_name"] == screenOutput["screen_name"]);
      if (screenOutputWithSameName) {
        screenOutput["tries"] = screenOutputWithSameName["tries"] + 1;
      } else {
        screenOutput["tries"] = 1;
      }

      output["questions"] = output["questions"].filter(output => output["screen_name"] !== screenOutput["screen_name"]);
    } else {
      screenOutput["practice"] = false;

      // if a screenOutput with the same screen name already exists, concatenate "REPEAT" to the screen name
      const screenOutputWithSameName = output["questions"].find(output => output["screen_name"] === screenName);
      if (screenOutputWithSameName) {
        screenOutput["screen_name"] = screenName + "-REPEAT";
        screenOutput["repeat"] = true;
      } else {
        screenOutput["repeat"] = false;
      }
    }

    output["questions"].push(screenOutput);
  }

  return [unanswered_questions, incorrect_questions];
}

function log_introduction() {
  const screenName = "introduction";
  const screenOutput = 
  {
    "screen_name": screenName,
    "time-elapsed": (new Date().getTime() - start_times[screenName]) / 1000,
  };

  if (!output["global"]) {
    output["global"] = [];
  }

  output["global"].push(screenOutput);
}

function log_submission() {
  const screenName = "submission";
  const screenOutput =
  {
    "screen_name": screenName,
    "time-elapsed": (new Date().getTime() - start_times[screenName]) / 1000,
  };

  if (!output["global"]) {
    output["global"] = [];
  }

  output["global"].push(screenOutput);

  const experimentOutput =
  {
    "screen_name": "experiment",
    "time-elapsed": (new Date().getTime() - start_times["introduction"]) / 1000,  
  }

  output["global"].push(experimentOutput);
}

// gets the next screen in the array of arrays that is screen order
function get_next_screen(sectionIdx, screenIdx) {
  let curr_screen_info = screen_order[sectionIdx][screenIdx];
  let curr_screen_name = generate_screen_name(curr_screen_info);

  let next_screen_info = null;
  let next_screen_name = null;

  if (screenIdx == screen_order[sectionIdx].length - 1) {
    if (sectionIdx == screen_order.length - 1) {
      return [undefined, undefined];
    } else {
      next_screen_info = screen_order[sectionIdx + 1][0];
      next_screen_name = generate_screen_name(next_screen_info);
      return [next_screen_info, next_screen_name];
    }
  } else {
    next_screen_info = screen_order[sectionIdx][screenIdx + 1];
    next_screen_name = generate_screen_name(next_screen_info);
    return [next_screen_info, next_screen_name];
  }
}

function increment_screen_index() {
  if (section_index < screen_order.length - 1 && screen_index == screen_order[section_index].length - 1) {
    section_index++;
    screen_index = 0;
  } else if (section_index < screen_order.length && screen_index < screen_order[section_index].length - 1) {
    screen_index++;
  }
}

function next_screen() {
  let curr_screen_info = screen_order[section_index][screen_index];
  let curr_screen_name = generate_screen_name(curr_screen_info);

  let [next_screen_info, next_screen_name] = get_next_screen(section_index, screen_index);

  if (curr_screen_info.type == "introduction") {
    log_introduction();
    deactivate_screen(curr_screen_info);
    increment_screen_index();
    activate_screen(next_screen_info, next_screen_name);
  } else {
    const is_practice = curr_screen_info.type == "practice";

    let[unanswered_questions, incorrect_questions] = log_checked_answers_with_sum(curr_screen_info, curr_screen_name);

    if (!is_practice) {
      incorrect_questions = {};
    }

    if (Object.keys(unanswered_questions).length > 0 || Object.keys(incorrect_questions).length > 0) {
      highlight_unanswered_questions(unanswered_questions, incorrect_questions);

      // if (Object.keys(incorrect_questions).length > 0 && !curr_screen_info['attempted']) {
      //   const studyType = curr_screen_info.study_type;
      //   const weights = generate_weights(feature_keys, 1);
      
      //   if (studyType == 'feed-selection' && practice_repeat_tally["feed-selection"] < 3) {
      //     const studyObj = generateFeedSelectionStudy(studyType, "left-feed-questions", 4, weights, 1, 0, true);
      //     screen_order[1].splice(screen_index + 1, 0, studyObj);
      //     practice_repeat_tally["feed-selection"]++;
      //   }

      //   if (studyType == 'feed-comparison' && practice_repeat_tally["feed-comparison-B"] < 3) {
      //     const studyObj = generateFeedComparisonStudy(studyType, "left-feed-questions", 4, weights, 1, 0, true);
      //     screen_order[1].splice(screen_index + 1, 0, studyObj);
      //     practice_repeat_tally["feed-comparison-B"]++;
      //   }

      //   if (studyType == 'post-placement' && practice_repeat_tally["post-placement"] < 3) {
      //     const studyObj = generatePostPlacementStudy(studyType, "left-feed-questions", 4, weights, 1, 0, true);
      //     screen_order[1].splice(screen_index + 1, 0, studyObj);
      //     practice_repeat_tally["post-placement"]++;
      //   }

      //   if (studyType == 'feature-selection' && practice_repeat_tally["feature-selection"] < 3) {
      //     const studyObj = generateFeatureSelectionStudy(studyType, "left-feed-questions", 4, weights, 1, 0, true);
      //     screen_order[1].splice(screen_index + 1, 0, studyObj);
      //     practice_repeat_tally["feature-selection"]++;
      //   }

      //   curr_screen_info['attempted'] = true;
      // }

    } else {
      deactivate_screen(curr_screen_info);
      increment_screen_index();
      activate_screen(next_screen_info, next_screen_name);
    }
  }

}

function deactivate_screen(screen_info) {
  let screen_type = screen_info['template'];
  window.scrollTo(0,0);
  document.getElementById(screen_type).style.display = 'none';
}

function activate_screen(screen_info, screen_name) {
  
  start_times[screen_name] = new Date().getTime();

  // find div with id screen-title and set its text to screen_name bootstrap
  let screen_title = document.getElementById("screen-title");
  let capitalizedType = screen_info.type.charAt(0).toUpperCase() + screen_info.type.slice(1);
  screen_title.innerHTML = capitalizedType;

  let top_bar = document.getElementById("top-bar");

  if (screenColors.hasOwnProperty(screen_info.type)) {
    top_bar.style.backgroundColor = screenColors[screen_info.type];
  } else {
    top_bar.style.backgroundColor = "#CCCCCC"; // Default color if screen type is not found
  }

  if (screen_info.type == "practice" || screen_info.type == "study") {
    let question_progress = document.getElementById("question-progress");
    question_progress.innerHTML = `Question ${screen_index + 1} of ${screen_order[section_index].length}`;
  }

  if (screen_info == undefined) {
    alert('Screen name ' + screen_name + ' is undefined');
    return;
  }

  let template = screen_info['template'];

  if (template == "left-feed-questions") {
    populate_LFQ(screen_info, screen_name);
  } else if (template == "single-post-question") {
    populate_SPQ(screen_info, screen_name);
  } else if (template == "submission") {
    document.getElementById("next-btn").style.display = "none";
  }

  document.getElementById(template).style.display = 'block';
  window.scrollTo(0,0);

  MathJax.typesetPromise().then(() => { });
}

function submit() {
  log_submission();
  proliferate.submit(output);
}

</script>
  <script type="text/javascript">

function removeEmojis(input) {
  const emojiPattern = /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F900}-\u{1F9FF}\u{1F1E0}-\u{1F1FF}\u{1F191}-\u{1F251}\u{1F004}\u{1F0CF}\u{1F170}-\u{1F171}\u{1F17E}-\u{1F17F}\u{1F18E}\u{3030}\u{2B50}\u{2B55}\u{2B05}-\u{2B07}\u{2B1B}-\u{2B1C}\u{3297}\u{3299}\u{23F0}\u{23F3}\u{231A}-\u{231B}\u{25FD}-\u{25FE}\u{2B50}\u{23E9}-\u{23EC}\u{2B05}-\u{2B07}\u{2B1B}-\u{2B1C}\u{2934}-\u{2935}\u{2B05}-\u{2B07}\u{27A1}]/gu;

  return input.replace(emojiPattern, '');
}

function removeHashtags(input) {
  const hashtagPattern = /#[^\s#]+/g;

  return input.replace(hashtagPattern, '');
}

// https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
function randn_bm(min, max, skew) {
  let u = 0, v = 0;
  while(u === 0) u = Math.random() //Converting [0,1) to (0,1)
  while(v === 0) v = Math.random()
  let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )
  
  num = num / 10.0 + 0.5 // Translate to 0 -> 1
  if (num > 1 || num < 0) 
    num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range
  
  else{
    num = Math.pow(num, skew) // Skew
    num *= max - min // Stretch to fill range
    num += min // offset to min
  }
  return Math.round(num);
}

function sanitizePosts(posts) {

  for (let i = 0; i < posts.length; i++) {
    // if the first character is an emoji, remove it 65% of the time
    if (posts[i].text.charCodeAt(0) >= 0x1F600 && posts[i].text.charCodeAt(0) <= 0x1F64F) {
      if (Math.random() < 0.65) {
        posts[i].text = posts[i].text.slice(2);
      }
    }

    // Randomly remove emojis, hashtags, exclamations, and uppercases
    if (Math.random() < 0.65) {
      posts[i].text = removeEmojis(posts[i].text);
    }

    if (Math.random() < 0.65) {
      posts[i].text = removeHashtags(posts[i].text);
    }

    if (Math.random() < 0.65) {
      posts[i].text = posts[i].text.replace(/!/g, '.');
    }

    if (Math.random() < 0.35) {
      posts[i].text = posts[i].text.toLowerCase();
    }

    // if the author_name is too long, remove the last word
    while (posts[i].author_name.length > 16 && posts[i].author_name.split(" ").length > 1) {
      posts[i].author_name = posts[i].author_name.split(" ").slice(0, -1).join(" ");
    }

    // if the author_name is still too long, remove the last characters starting at the last capital letter
    if (posts[i].author_name.length > 18) {
      const lastCapitalIndex = posts[i].author_name.split("").reverse().join("").search(/[A-Z]/);
      posts[i].author_name = posts[i].author_name.slice(0, -lastCapitalIndex);
    }

    // Assign days_since_posted
    posts[i].days_since_posted = randn_bm(0, 500, 4);

    // Assign view_count, like_count, and comment_count
    posts[i].view_count = randn_bm(0, 2500, 4);

    posts[i].like_count =  randn_bm(posts[i].view_count / 6, posts[i].view_count, 1.1);

    posts[i].comment_count = randn_bm(posts[i].like_count / 6, posts[i].like_count, 1.5);
  }
}

</script>
  <script type="text/javascript">

/* takes in a feed array of posts and weights it's features according to the weights dictionary 
 */
function linear_combination_sort(feed, weights) {
    feed.sort(function(a, b){
        let a_score = 0;
        let b_score = 0;
        for (let key in weights) {
            if (key == "character_count") {
                a_score += weights[key] * a["text"].length;
                b_score += weights[key] * b["text"].length;
            } else {
                a_score += weights[key] * a[key];
                b_score += weights[key] * b[key];
            }   
        }
        return  b_score - a_score;
    });
}

// given an array of features (strings) and the number of features that should have
// weight > 0, generates a random weight dictionary
function generate_weights(features, num_features) {
    let weights = {};
    let num_features_set = 0;
    while (num_features_set < num_features) {
        let random_feature = features[Math.floor(Math.random() * features.length)];
        if (weights[random_feature] == undefined) {
            do {
                weights[random_feature] = truncate(Math.random() * 2 - 1);
            } while (Math.abs(weights[random_feature]) <= 0.1);
            num_features_set++;
        }
    }

    // if weights only has one entry, set it to 1 or -1 (depending on its sign)
    if (Object.keys(weights).length == 1) {
        let key = Object.keys(weights)[0];
        weights[key] = weights[key] >= 0 ? 1 : -1;
    }

    // set all other features to 0
    for (let feature of features) {
        if (weights[feature] == undefined) {
            weights[feature] = 0;
        }
    }

    return weights;
}

// function permute_weights(weights) {
// modifies the weights dictionary with one of the weights changed
// returns a the name of the weight that was changed
function permute_weights(weights) {
    let keys = Object.keys(weights);
    let random_key = keys[Math.floor(Math.random() * keys.length)];
    weights[random_key] = truncate(Math.random() * 2 - 1);
    return random_key;
}

// function permute_weights_valence(weights) {
// modifies the weights dictionary with one of the weights changed to another sign
// returns a the name of the weight that was changed
function permute_weights_valence(weights) {
    let keys = Object.keys(weights);

    let random_key = keys[Math.floor(Math.random() * keys.length)];

    if (weights[random_key] == 0) {
        do {
            weights[random_key] = truncate(Math.random() * 2 - 1);
        } while (Math.abs(weights[random_key]) <= 0.1);
    } else {
        weights[random_key] = -weights[random_key];
    }
    
    return random_key;
}

</script>
  <script>

var questions_column_width;
var feature_dict = 
{
    "days_since_posted": "Hours Since Posted", 
    "like_count": "Like Count", 
    "view_count": "View Count", 
    "comment_count": "Comment Count", 
    "character_count": "Character Count"
};

const screenColors = {
  introduction: "#BBBBBB", // gray?
  practice: "#00BFFF",     // Deep Sky Blue
  study: "#32CD32",        // Lime Green
  submission: "#FF6347"    // Tomato Red
};


var feature_keys = Object.keys(feature_dict);
var feature_names = Object.values(feature_dict);

var startTime;

sanitizePosts(json_posts["posts"]);
shuffle_array(json_posts["posts"]);

let screen_order = generate_study_array(["feed-comparison-B", "post-placement", "feature-selection"], 
                                        [1, 2, 5], 
                                        2, 
                                        "left-feed-questions", 
                                        feature_keys, 
                                        8,
                                        true);
let section_index = 0;
let screen_index = 0;

var start_times = {};

var practice_repeat_tally = {
    "post-placement": 0,
    "feed-comparison-B": 0,
    "feed-selection": 0,
    "feature-selection": 0,
};

output = {
    
}

</script>
  <script type="text/javascript">

function main() {
  activate_screen(screen_order[0][0], "introduction");
}

main();

</script>


  </div>
</body>
</html>
