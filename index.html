<!-- This is the starting page for the survey.-->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">

  <title>Study</title>
  <!-- <script src="https://proliferate.alps.science/static/js/proliferate.js" type="text/javascript"></script> -->
  <!-- <script src="https://unpkg.com/@jspsych-contrib/plugin-pipe"></script> -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
html, body {
  margin: 0;
  height: 100%;
}

body {
  padding-top: 6.9vh;
  background-color: white;
}

#top-bar {
  height: 6.9vh;
}

.screen {
  height: 100vh;
}
.caption {
  display: block; 
} 

#bottom-bar {
  height: 0;
}

.feed-container {
  border: rgba(0, 0, 0, .5);
}

.feed-label {
  z-index: 1;
  width: 100%;
  margin: 0 auto;
  border-radius: 5px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.label-container {
  background-color: #eee;
}

label {
  cursor: pointer;
}

input {
  cursor: pointer;
}

input[type="range"] {
  width:400px;
}

img {
  max-height: 50vh;
  width: auto;
}

#next-btn {
  height: 40px;
  width: 60px;
  margin-top: -9vh;
  margin-right: 2vh;
  z-index: 50;
}

.selected-label {
  color: white;
}

.visible-scrollbar::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 9px;
}

.visible-scrollbar::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0, 0, 0, .5);
  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);
}

.feed-scroll {
  border: 2px solid #ccc;
  padding-bottom: -100px !important;
  scroll-padding-bottom: 0;
  border-radius: 5px;
  max-height: 87vh;
  overflow: scroll;
}

.question-upper-container { 
  margin: 20px;
/*  position: sticky;
*/ }

.question-container {
/*  max-height: 700px;
*//*  width: 230px;
*/  word-wrap: break-word;
}

.time {
  font-size: 3px !important;
}

.post {
  padding: 8px;
  margin: 5px 0;
  border: 1px solid #ccc;
  border-radius: 6px;
}

.feeds {
  width: 600px;
}

.author-info {
  display: flex;
  align-items: center;
}

.author-info img {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  margin-right: 10px;
}

.post .font-weight-bold {
  font-size: 14px;
}

.post .small-text {
  font-size: 14px;
  color: #888;
}

.small-text {
  font-size: 17px;
}

.post .xs-text {
  font-size: 10px;
  color: #888;
}

.post .socials {
  justify-content: flex-end;
  gap: 10px;
}

.post .social-item {
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 12px;
/*  color: #888;
*/}

.count {
  font-size: 14px !important;
  color: #888;
}

.highlighted {
  font-weight: bold;
  color: red !important;
  background-color: rgba(255, 0, 0, 0.2);
  padding: 2px;
  border-radius: 4px;
}

.highlighted-text {
  background-color: rgba(255, 255, 0, 0.67);
}

.static {
  border: 2px solid rgb(182, 182, 182) !important;
  opacity: 0.9;
}

.second-static {
/*  border: 2px solid lightgray !important;
*/  border: 2px solid rgb(182, 182, 182) !important;
  /*opacity: 0.7;*/
  opacity: 0.9;
  background: #f0f9ff;
}

.unmoveable {
/*  border: 2px solid lightgray !important;
*/  border: 2px solid rgb(182, 182, 182) !important;
  /*opacity: 0.7;*/
  opacity: 0.9;
  background: #f0f9ff;
}

.exposure-posts {
  opacity: 0.9;
border: 2px solid rgb(182, 182, 182) !important;
}

.post:not(.static, .second-static, .exposure-posts) {
  z-index: 9999;
  border: 3px solid rgb(182, 211, 229) !important;
  cursor: grab;
}

.post:not(.static, .second-static, .exposure-posts).ui-sortable-helper {
  cursor: grabbing;
}

ul li, ol li {
  list-style: none;
  margin: 0;
  padding: 0;
}

.feed-list-bank {
  background-color: #f9f9f9;
  border: 1px solid #ccc;
  padding: 10px;
  margin: 2px;
  border-radius: 5px;
  min-height: 100px;
}

.redacted {
  background-color: gray;
  color: gray;
}
</style>  
</head>

<body>

  <!-- display area -->
  <div id="display-area" class='container-fluid px-1'>
    <div class="container-fluid mt-0 text-white fixed-top" id="top-bar">
  <div class="d-flex justify-content-between py-2 px-4">
    <h3 id="screen-title" class="m-0">Screen Title</h3>
    <div id="question-progress" class="m-2">
    </div>
  </div>
</div>
    <div class='row p-2 ' id='introduction' style="display:none;">
    <div class='col-10'>
        <div class="card pb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-6">
                        <p style="font-size: 18px;">
                            You are invited to participate in a research study on user understanding of algorithms and models. 
                            You will be asked to answer multiple choice and free response questions about different provided algorithms and their expected behavior. 
                            You will not be recorded via audio or video.
						</p>
						<p style="font-size: 18px;">
                            TIME INVOLVEMENT: Your participation will take approximately 30 minutes.
						 </p>
                         <p style="font-size: 18px;">
                            PAYMENTS: You will receive $7.50 via the survey platform upon completion of the study, and you will receive additional compensation of $0.10 per correct answer afterwards, as payment for your participation. A total of up to $1.50 in bonuses is available.
						 </p>
                         <p style="font-size: 18px;">
                            RISKS AND BENEFITS: The risks associated with this study are minimal. 
                            A potential data breach or breach of confidentiality should not adversely affect employment or reputation. 
                            Study data will be stored securely, in compliance with Stanford University standards, minimizing the risk of confidentiality breach. 
                            You may be exposed to content that is upsetting, as this study involves a wide array of social media posts, some of which contain harmful text (e.g., profanity, slurs, expressions of bigotry like racism/sexism/homophobia/religious intolerance, discussion of violence, jokes about tragedies). 
                            The benefits which may reasonably be expected to result from this study are none. 
                            We cannot and do not guarantee or promise that you will receive any benefits from this study. 
						 </p>
                         <p style="font-size: 18px;">
                            PARTICIPANTâ€™S RIGHTS: If you have read this form and have decided to participate in this project, please understand your participation is voluntary and you have the right to withdraw your consent or discontinue participation at any time without penalty or loss of benefits to which you are otherwise entitled. 
                            The alternative is not to participate. 
                            You have the right to refuse to answer particular questions. 
                            The results of this research study may be presented at scientific or professional meetings or published in scientific journals. 
                            Your individual privacy will be maintained in all published and written data resulting from the study. 

						 </p>
                         <p style="font-size: 18px;">
                            CONTACT INFORMATION: If you have any questions, concerns or complaints about this research, its procedures, risks and benefits, contact the Protocol Director, Lindsay Popowski, at popowski@stanford.edu or 541-224-4303. 
                            
						 </p>
                         <p style="font-size: 18px;">
                            Independent Contact: If you are not satisfied with how this study is being conducted, or if you have any concerns, complaints, or general questions about the research or your rights as a participant, please contact the Stanford Institutional Review Board (IRB) to speak to someone independent of the research team at 650-723-2480 or toll free at 1-866-680-2906, or email at irbnonmed@stanford.edu. You can also write to the Stanford IRB, Stanford University, 1705 El Camino Real, Palo Alto, CA 94306.

						 </p>

						
						<p> <b>To indicate your consent to participate in this study, select the Next button below to continue on to the study.</b></p>
                        <button type="button" class="btn btn-primary" id="intro-next-btn" onclick="next_screen()">Next</button>
                          <script>
                            var next_button = document.getElementById("intro-next-btn");

                            // function to simulate button click when enter key is pressed
                            function activateNextButton(event) {
                                if (event.key === "Enter") {
                                    next_button.click();
                                }
                            }
                            document.addEventListener("keydown", activateNextButton);
                        </script>
                    </div>
                    <div class="col-6" id="post-container" style="padding: 10px; margin-bottom: 50px;">
                        <div id="intro-post" style="width: 90%; height: auto; max-width: 100%; "></div>
                        <p style="text-align: center;"><i>Example post</i></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <div class='row p-2 ' id='practice_intro' style="display:none;">
    <div class='col-10'>
        <div class="card pb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-6">
                        <p style="font-size: 18px;">
						You have now begun the practice section.
						</p>
						<p style="font-size: 18px;">
                            There will be 10 practice questions with feedback. 
                            You can select "See Feed Again" to revisit the feed exposure that you saw before.
						 </p>
						<p> <b>Click next to progress to the practice questions.</b></p>
                        <button type="button" class="btn btn-primary" id="intro-next-btn" onclick="next_screen()">Next</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <div class='row p-2 ' id='questions_intro' style="display:none;">
    <div class='col-10'>
        <div class="card pb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-6">
                        <p style="font-size: 18px;">
                            You have now begun the main questions section.
						</p>
						<p style="font-size: 18px;">
                            There will be 30 questions in total, now without feedback.
                            These questions are scored, with correct answers being bonused.
						 </p>
						<p> <b>Click next to progress to the questions.</b></p>
                        <button type="button" class="btn btn-primary" id="intro-next-btn" onclick="next_screen()">Next</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <div class='row p-2' id='submission' style="display:none;">
	<div class='col-12'>
		<div class="card">
			<div class="card-body">
				<p>Thank you for completing our entire study! 	
				Please <strong>click submit.</strong> It may take a moment to redirect you.</p>
				<button type="button" class="btn btn-primary" id='submit-btn-1' onclick="submit()">Submit</button>
				</form>
			</div>
		</div>
	</div>
</div>
    <div class='row p-2 ' id='return_screen' style="display:none;">
    <div class='col-10'>
        <div class="card pb-4">
            <div class="card-body">
                <div class="row">
                    <div class="col-6">
                        <p style="font-size: 18px;">
                            You have failed too many of the attention checks to proceed. 
                            
                            Please return this study by closing the survey and clicking 'Stop Without Completing'.
						</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <div class="container-fluid p-0" id="feed-and-sidebar" class="screen" style="display:none;">
	<div class="row justify-content-center">
		<div class = "question-upper-container justify-content-center">
	  <div class="feed-container" id="FS-feed-container">
		<div class="feeds" id="FS-feeds">
		</div>
		<div class="feeds" id= "exposure-bar">
	  	</div>

		</div>
	</div>
	  <div class='col-5'>
	  	<div class = "question-upper-container card justify-content-center">
	  	<div class = "question-container card-body">

	  	<div id="FS-sidebar">
	  	</div>

		</div>
	  </div>
	<div id = "task-button" style ="padding-top: 120px; padding-left: 5px">
	  		<div class='col-5'>

	  			<div class="alert alert-success" style='display: none' role="alert" id = "right-btn-cntr">
				 	Correct!&emsp;<a href="#" class="alert-link float-right" onclick="next_screen()" id = "right-btn">Continue</a>
				</div>
				<div class="alert alert-danger" style='display: none' role="alert" id = "wrong-btn-cntr">
				 	Incorrect!&emsp;<a href="#" class="alert-link float-right" onclick="next_screen()" id = "wrong-btn">Continue</a>
				</div>
				<!-- <button type="button" class="btn btn-primary" id="exposure-btn" onclick="see_feed_again()" style='display: none'>See Feed Again</button>
				<br><br> -->

				<button type="button" class="btn btn-primary" id="next-btn" onclick="next_screen()" style='display: inline-block'>Next</button>
<!-- 				<div class="alert alert-secondary" style='display: inline-block;' role="alert"> Click to continue<a href="#" class="alert-link float-right" id = "next-btn">Continue</a>
 -->				</div>

<!-- 	  	<button type="button" class="btn btn-primary" id="next-btn" onclick="next_screen()" style='display: inline-block'>Next</button>
 -->			  
 			<!-- <script>
			    var next_button = document.getElementById("next-btn");

			    // function to simulate button click when enter key is pressed
			    function activateNextButton(event) {
			        if (event.key === "Enter") {
			            next_button.click();
			        }
			    }
			    document.addEventListener("keydown", activateNextButton);
			</script> -->
		</div>
	</div>
	</div>
</div>
</div>
    <div class="row p-2" id="centered-content" style="display:none;">
    <div class="col-12">
      <div class="card pb-4">
        <div id="CC-body" class="card-body">
        </div>
      </div>
    </div>
        <button type="button" class="btn btn-primary" id="final-next-btn" onclick="next_screen()">Next</button>
              <!-- <script>
                var next_button = document.getElementById("final-next-btn");

                // function to simulate button click when enter key is pressed
                function activateNextButton(event) {
                    if (event.key === "Enter") {
                        next_button.click();
                    }
                }
                document.addEventListener("keydown", activateNextButton);
            </script> -->
</div>
    <!-- Helena moved this to introduction.html, feed_and_sidebar.html, and centered_content.html on May 28-->

<!-- <div class="container-fluid mt-0" id="bottom-bar" style="display:block;">
  <div class="d-flex justify-content-end">
	<button type="button" class="btn btn-primary" id="next-btn" onclick="next_screen()">Next</button>
  </div>
  <script>
    var next_button = document.getElementById("next-btn");

    // function to simulate button click when enter key is pressed
    function activateNextButton(event) {
        if (event.key === "Enter") {
            next_button.click();
        }
    }
    document.addEventListener("keydown", activateNextButton);
</script>

</div>
   -->
  </div>

  <script type='text/json' id='input'>
  
</script>
<!-- MATT: Do we need this button? -->
<!-- <form id='results-form' method='post' action='dummy' class='text-center'>
  <input type='hidden' value='' name='assignmentId' id='assignmentId'/>
  <input type='hidden' value='' name='output' id='output'/>
  <input type='submit' class='btn btn-lg btn-success' id='submit-btn' value='Submit' disabled/>          
</form> -->
<script>
  var easyturk = (function() {
    
    // Copied from http://james.padolsey.com/javascript/bujs-1-getparameterbyname/
    function getUrlParam(name) {
      var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
      return match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : null;
    }

    function getInput(default_input) {
      if (typeof(default_input) === 'undefined') default_input = null;
      try {
        return JSON.parse($('#input').html());
      } catch (e) {
        return default_input;
      }
    }

    function setOutput(output) {
      $('#output').val(JSON.stringify(output));
    }

    function isPreview() {
      return false;
      var assignment_id = getUrlParam('assignmentId');
      if (assignment_id === null) return false;
      return assignment_id == 'ASSIGNMENT_ID_NOT_AVAILABLE';
    }

    function setupSubmit() {
      var submit_to = getUrlParam('turkSubmitTo');
      $('#results-form').attr('action', submit_to + '/mturk/externalSubmit');                      
      $('#assignmentId').val(getUrlParam('assignmentId'));
    }

    return {
      getInput: getInput,
      setOutput: setOutput,
      isPreview: isPreview,
      setupSubmit: setupSubmit,
    }

  })();
</script>
  
  <!-- <script type="text/javascript" src="templates/feed_data/generic_posts.js"></script>
  <script type="text/javascript" src="templates/feed_data/concept_feeds.js"></script> -->
  <!-- <script type="text/javascript" src="templates/feed_data/extra_dummy_posts.js"></script> -->
  <script type="text/javascript" src="templates/feed_data/dummy_alg_posts_2.js"></script>
  <script type="text/javascript" src="templates/feed_data/safe_indices.js"></script>
  <script type="text/javascript" src="templates/feed_data/algorithm_info.js"></script>

  <script type="text/javascript">
    const question_screens = [
  /*"feed_comparison" , "post_arrangement" /*"counterfactual_placement",*/ "post_placement", "post_placement_check_1", "post_placement_check_2", "post_placement_check_3", "post_placement_check_4", "post_placement_check_5", "exposure_intro_1", "exposure_intro_2", "exposure_intro_3", "exposure_intro_4"
];

const question_screen_types = ["post_placement"]
const possible_num_features = [1];
const num_features =
  possible_num_features[
    Math.floor(Math.random() * possible_num_features.length)
  ];

const num_same_features_and_question = 30;

const set_posts = true;
var study_indices = null;

// const possible_conditions = ["A"];

// const possible_conditions = ["severe_toxicity_noise_0.5", "severe_toxicity_noise_0.8", "first_person_pronouns"]
const possible_conditions = ["likes_ratio_strict", "odder_engagement", "likes_ratio"];
// const possible_conditions = ["gpt_quality", "severe_toxicity", "factual", "chronological", "likes", "likes_ratio", 
//   "random", "Caring", "first_person_pronouns", "hashes", "conservative_values", "parts_of_speech"];

// const possible_conditions = ["chronological", "likes", 
// "engagement_soup", "first_person_pronouns", 
// "bad_positivity", "value_regression",
// "random",
// "hashes"]

// const possible_conditions = ["chronological", "likes", 
// "engagement_soup", "first_person_pronouns", 
// "bad_positivity", "value_regression",
// "random", "parts_of_speech", "Caring",
// "hashes", "conservative_values"]

var safe_indices = [];
var condition = "likes_ratio";
const condition_chosen = possible_conditions[
  Math.floor(Math.random() * possible_conditions.length)
];
if (condition_chosen == "likes_ratio_strict") {
  safe_indices = safe_indices_LR;
  condition = "likes_ratio"
} else if (condition_chosen == "likes_ratio") {
  safe_indices = rand_indices_LR;
  condition = "likes_ratio";
} else if (condition_chosen == "odder_engagement") {
  safe_indices = rand_indices_OE;
  condition = "odder_engagement";
}

if (set_posts) {
  study_indices = safe_indices[
    Math.floor(Math.random() * safe_indices.length)
  ];
}


// const concept_index = Math.floor(
//   Math.random() * concept_feeds.length
// );
// const source_posts = concept_feeds[concept_index][0];


const num_posts_per_screen = 1;
const num_posts_at_load = 12;
const num_posts_to_load = 6;
const max_num_posts_possible = 50;
const num_buckets = 8;
const bucketing = true;
const algorithms_already_created = true;


let source_posts;
if (bucketing && !set_posts) {
  alg_posts.sort((a,b) => a[condition] - b[condition]);
  source_posts = generate_posts_from_buckets(alg_posts, num_buckets, alg_posts.length, extreme=true);//alg_posts, generic_posts;
} else if (set_posts) {
  alg_posts.sort((a,b) => a[condition] - b[condition]);
  source_posts = generate_posts_from_buckets(alg_posts, num_buckets, alg_posts.length, extreme=false);//alg_posts, generic_posts;
}
else {
  source_posts = generic_posts;
}


const num_practice = 10;

// TODO: update these to reflect twitter
var feature_dict = {};
var feature_keys = []
var feature_names = []
if (!algorithms_already_created){
  feature_dict = {
    days_since_posted: "Hours Since Posted",
    like_count: "Like Count",
    // "view_count": "View Count",
    comment_count: "Comment Count",
    // "character_count": "Character Count",
    // "repost_count": "Repost Count",
  };
  feature_keys = Object.keys(feature_dict);
  feature_names = Object.values(feature_dict);
} else {
  // feature_dict = Object.keys(alg_posts[0])
  feature_keys = Object.keys(alg_posts[0]);
  feature_names = Object.keys(alg_posts[0]);
  feature_dict = {
    likes: "likes",
    replies: "replies",
    retweets: "retweets",
    views: "views",
    time_since: "ago"
  }
  // feature_dict = feature_keys.reduce((obj, k, i) => ({...obj, [k]: feature_names[i] }), {})
}

// TODO: need to set it to 1 for the correct algorithm, and 0 for the rest
// const study_weights = generate_weights(feature_keys, num_features, true);
const study_weights = generate_weights(feature_keys, num_features, true, algorithms_already_created, condition);


// these are feed items we want redacted based on class names in 'bulding_blocks.js'
const redacted_classes = []; // ['post_text', 'author-name'];
const any_redacted = redacted_classes.length > 0;

const include_confidence = false;
const num_confidence = 4
var practice_confidence_indices = [1]
var question_confidence_indices = [1,10,20,30]
var questions = [];
// for (var i=0;i<num_same_features_and_question;i++) {
//   questions.push(i);
// }
// for (let i = 0; i<num_confidence; i++) {
//   let random_question = Math.floor(Math.random() * questions.length);
//   question_confidence_indices.push(questions[random_question]);
//   questions.splice(random_question, 1);
// }


const SCREEN_TYPE_INFO = {
  introduction: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
In the upcoming screens, you'll be presented with some social media feeds and asked to answer some 
questions about them. The posts in these feeds will be sorted by some combination of the features 
highlighted in the diagram to the right.

You will receive **$0.15 for each correct answer**. After each question, you will also be asked to 
assess how confident you are in your answer. Correct self-assessment will be bonused up to $0.06.

**Click next (or press enter) to start.**
    `,
      },
    ],
  },

//   exposure: {
//     template_id: "feed-and-sidebar",
//     sidebar_entries: [
//       {
//         markdown: `
// From now on, you will not be explictly told the criteria behind which post to choose.

// **Instead, you should choose the post most like those in this feed.**
// Posts in Your Feed are chosen out of all political posts possible because they are ranked the most highly according to some condition.
// **Note that all posts are political, but this is not their defining similarity.**

// Please spend several minutes looking at your feed (to the left) and trying to determine what these posts were chosen for.
// The ranking could involve many different things, including both aspects of the text and interactions like the number of replies.
// *Keep in mind that AI can make mistakes*.

// All following questions in the study will ask you to select posts based on this feed.
// You will start out with a practice phase which includes feedback. You will be able to refer back to this feed during the practice phase, but not during the scored section.
// <button id = "load-more-button"></button>
// ${
//           any_redacted
//             ? `*Some text has been redacted because 
// it is not relevant to the tasks.*`
//             : ""
//         }
//         `,
//       },
//     ],
//   },

  post_exposure: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
This feed represents a sample of the posts you might see throughout this task, in no particular order.
Please spend a minute scrolling through the posts to get an idea of what types of posts you could be shown.
Use the text box below to briefly describe the commonalities of these posts, as well as some of the ways that they differ.
${
          any_redacted
            ? `*Some text has been redacted because 
it is not relevant to the tasks.*`
            : ""
        }
        `,
        answer_area: "text_input",
      },
    ],
  },


  exposure_intro_1: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
You will now start the main part of the study, where you will not be explictly told how to arrange the posts.

Next, you will see a feed of political social media posts. They are sorted by an algorithm, but not by the algorithm that is usually used on social media. Your job is to figure out what the algorithm is doing.

You should look at the text AND the displayed features like engagement and time posted.

All following questions in the study will ask you to rank posts based on this algorithm.
        `,
      },
      {
        markdown: `
Can the feed be ordered using numeric information about the post such as engagement and time posted?
        `,
        answer_area: "multiple_choice",
        options: ["Yes", "No"],
        option_key: [1,0],
      },

    ],
  },

  exposure_intro_2: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
You will now start the main part of the study, where you will not be explictly told how to arrange the posts.

Next, you will see a feed of political social media posts. They are sorted by an algorithm, but not by the algorithm that is usually used on social media. Your job is to figure out what the algorithm is doing.

You should look at the text AND the displayed features like engagement and time posted.

All following questions in the study will ask you to rank posts based on this algorithm.
        `,
      },
      {
        markdown: `
Can the feed be ordered using the text content of the post?
        `,
        answer_area: "multiple_choice",
        options: ["Yes", "No"],
        option_key: [1,0],
      },
    ],
  },

  exposure_intro_3: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
You will now start the main part of the study, where you will not be explictly told how to arrange the posts.

Next, you will see a feed of political social media posts. They are sorted by an algorithm, but not by the algorithm that is usually used on social media. Your job is to figure out what the algorithm is doing.

You should look at the text AND the displayed features like engagement and time posted.

All following questions in the study will ask you to rank posts based on this algorithm.
        `,
      },
      {
        markdown: `
Can the feed be ordered using the color of the profile image?
        `,
        answer_area: "multiple_choice",
        options: ["Yes", "No"],
        option_key: [0,1],
      },
    ],
  },

  exposure_intro_4: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
You will now start the main part of the study, where you will not be explictly told how to arrange the posts.

Next, you will see a feed of political social media posts. They are sorted by an algorithm, but not by the algorithm that is usually used on social media. Your job is to figure out what the algorithm is doing.

You should look at the text AND the displayed features like engagement and time posted.

All following questions in the study will ask you to rank posts based on this algorithm.
        `,
      },
      {
        markdown: `
Does the feed contain only political posts, or can they be about any topic?
        `,
        answer_area: "multiple_choice",
        options: ["Only Politics", "All Topics"],
        option_key: [1,0],
      },
    ],
  },

  exposure: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
This is Your Politics Feed: a feed of political social media posts. They are sorted by an algorithm, but not by the algorithm that is usually used on social media. 

Try to figure out what the algorithm is doing by looking at the text AND the displayed features like engagement and time posted, all of which COULD be involved.

All following questions in the study will ask you to rank posts based on this algorithm.
<button id = "load-more-button"></button>
${
          any_redacted
            ? `*Some text has been redacted because 
it is not relevant to the tasks.*`
            : ""
        }
        `,
      },
    ],
  },

  correct_response: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
Below is how the posts on the previous screen would've been correctly arranged.
        `,
        answer_area: "post_bank",
      },
    ],
  },

  post_arrangement: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
Recall how the feed you saw at the beginning was ordered. Arrange the following posts to imitate that 
ordering.
`,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },

  post_placement: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
Consider the following two posts. Order them according to how you think the earlier feed was ranked, with the post more likely to be shown at the top.
        `,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },

//   post_placement: {
//     template_id: "feed-and-sidebar",
//     sidebar_entries: [
//       {
//         markdown: `
// Consider the following two posts. Choose the most more likely to be included in Your Feed, and move it to the box on the left.
//         `,
//         answer_area: "post_bank",
//         includes_confidence: include_confidence,
//       },
//     ],
//   },

// post_placement_check_1: {
//   template_id: "feed-and-sidebar",
//   sidebar_entries: [
//     {
//       markdown: `
// We will start off with a practice of the selection task. Consider the following two posts. Arrange the posts so that the one that starts with "My" is on top.
//       `,
//       answer_area: "post_bank",
//       includes_confidence: include_confidence,
//     },
//   ],
// },

//   post_placement_check_2: {
//     template_id: "feed-and-sidebar",
//     sidebar_entries: [
//       {
//         markdown: `
// Consider the following two posts. Arrange the posts so the one with more words is on top.
//         `,
//         answer_area: "post_bank",
//         includes_confidence: include_confidence,
//       },
//     ],
//   },


post_placement_check_1: {
  template_id: "feed-and-sidebar",
  sidebar_entries: [
    {
      markdown: `
We will start off with a practice of the selection task. Consider the following two posts. Arrange the posts so that the one on top is the one with a larger number.
      `,
      answer_area: "post_bank",
      includes_confidence: include_confidence,
    },
  ],
},

  post_placement_check_2: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
Consider the following two posts. Arrange the posts so the one you think is more likely to be true is on top.
        `,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },


  post_placement_check_3: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
We will start off with a practice of the selection task. Consider the following two posts. Arrange the posts so the one with more adjectives is on top.
        `,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },

  post_placement_check_4: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
We will start off with a practice of the selection task. Consider the following two posts. Arrange the posts so the one where the word "she" appears more is on top.
        `,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },

  post_placement_check_5: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
We will start off with a practice of the selection task. Consider the following two posts. Arrange the posts so the one with more second person pronouns (you, your, yours) is on top.
        `,
        answer_area: "post_bank",
        includes_confidence: include_confidence,
      },
    ],
  },


  counterfactual_placement: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
Look at how your feed today was sorted. If the given post changed as highlighted above, would its placement 
now be higher, unchanged, or lower?
        `,
        answer_area: "multiple_choice",
        includes_confidence: include_confidence,
      },
    ],
  },

  feed_comparison: {
    template_id: "feed-and-sidebar",
    sidebar_entries: [
      {
        markdown: `
The feed to the left is your feed today. To the right is a new feed you're presented with tomorrow. Is tomorrow's 
feed sorted differently from your feed today? 
        `,
        answer_area: "multiple_choice",
        includes_confidence: include_confidence,
      },
    ],
  },

  submission: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
Thank you for completing the analytic portion of our study! Please **click submit.** It may take a moment to redirect you to the final part on Qualtrics.
    `,
      },
    ],
  },

  feedback: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
How do you think the algorithm worked for the feed ranking you saw? Descibe what you think would make one post be ranked above another.
Examples: "it was ranked by most replies" OR "it was ranked by being more about the economy" NOT "it was ordered by an algorithm"
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
What evidence helped you figure out how the feed was ordered? What was your process for developing your theory and did it change? Describe what parts of the study helped you (seeing the feed, practice).
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
How long did it take you to solidify how you thought the algorithm worked? Was there a certain number of posts or practice questions that it took?
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
Were there any particular questions that you struggled with? What made them difficult?
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
How many questions (out of 30) do you think you got right? How many did you guess on?
        `,
        answer_area: "text_input",
      },
    ],
  },

  feedback_2: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
Your feed was ranked by ${alg_descriptions[condition]}. How close do you think your idea was to the real algorithm?
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
Given that information, how many questions (out of 30) do you think you got right?
        `,
        answer_area: "text_input",
      },
      {
        markdown: `
Do you have any feedback on the study? (enter "none" if you have none)
        `,
        answer_area: "text_input",
      },
    ],
  },

  feedback_3: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
For the following questions, "the task" refers to the process of both figuring out what the algorithm is, and applying it to different posts.
        `,
      },
      {
        markdown: `
How mentally demanding was the task? 
        `,
        answer_area: "slider",
        options: ["Very low", "Very high"],
      },
      {
        markdown: `
How hurried or rushed was the pace of the task?? 
        `,
        answer_area: "slider",
        options: ["Very low", "Very high"],
      },
      {
        markdown: `
How successful were you in accomplishing what you were asked to do? 
        `,
        answer_area: "slider",
        options: ["Perfect", "Failure"],
      },
      {
        markdown: `
How hard did you have to work to accomplish your level of performance?  
        `,
        answer_area: "slider",
        options: ["Very low", "Very high"],
      },
      {
        markdown: `
How insecure, discouraged, irritated, stressed, and annoyed were you? 
        `,
        answer_area: "slider",
        options: ["Very low", "Very high"],
      },
    ],
  },

  feedback_4: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
To what extent do you agree with the following statements?
        `,
      },
      {
        markdown: `
I would prefer complex to simple problems.
        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
      {
        markdown: `
I like to have the responsibility of handling a situation that requires a lot of thinking.
        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
      {
        markdown: `
Thinking is not my idea of fun.
        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
      {
        markdown: `
I would rather do something that requires little thought than something that is sure to challenge my thinking abilities.
        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
      {
        markdown: `
I really enjoy a task that involves coming up with new solutions to problems.
        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
      {
        markdown: `
I would prefer a task that is intellectual, difficult, and important to one that is somewhat important but does not require much thought.        `,
        answer_area: "multiple_choice",
        options: ["Strongly disagree", "Somewhat disagree", "Neither agree nor disagree", "Somewhat agree", "Strongly agree"],
        option_key: [-2, -1, 0, 1, 2],
      },
    ],
  },

  feedback_5: {
    template_id: "centered-content",
    entries: [
      {
        markdown: `
In the past year, how often have you used social media (e.g. Twitter, Facebook, Instagram)?        `,
        answer_area: "multiple_choice",
        options: ["Not at all", "Less than once a month", "At least once a month", "At least once a week", "Two to three times a week", "Daily"],
        option_key: [1, 2, 3, 4, 5, 6],
      },
      {
        markdown: `
In the past year, how often have you read articles or heard discussion about social media algorithms?        `,
        answer_area: "multiple_choice",
        options: ["Not at all", "Less than once a month", "Once a month", "Once a week", "Several times a week", "Daily"],
        option_key: [1, 2, 3, 4, 5, 6],
      },
    ],
  },
};
    const SECTION_COLORS = {
  introduction: "#BBBBBB", // Gray
  practice: "#00BFFF", // Deep Sky Blue
  exposure: "#FFD700", // Gold
  questions: "#32CD32", // Lime Green
  submission: "#FF6347", // Tomato Red
  feedback: "#800080", // Purple
  default: "CCCCCC",
};

const FEATURE_ICON_DICT = {
  days_since_posted: "fa fa-clock-o",
  time_posted: "fa fa-clock-o",
  time_since: "fa fa-clock-o",
  like_count: "fa fa-thumbs-up",
  likes: "fa fa-thumbs-up",
  view_count: "fa fa-eye",
  views: "fa fa-eye",
  comment_count: "fa fa-comments-o",
  replies: "fa fa-comments-o",
  character_count: "fa fa-font",
  repost_count: "fa fa-retweet",
  retweets: "fa fa-retweet"
};

    /**
 * Inserts a feed label into the labels container.
 *
 * @param {string} label_text - The text of the label.
 * @param {HTMLElement} label_container - The container where the label will be inserted.
 * @param {number} label_width - The width of the label container.
 */
function insert_label(label_text, label_container, label_width) {
  const label_div = document.createElement("div");
  label_div.className = `col-${label_width} d-flex align-items-center justify-content-center`;
  label_div.innerHTML = `<div class="feed-label pt-2">
  <span class="h2">${label_text}</span>
</div>`;
  label_container.appendChild(label_div);
}

/**
 * Inserts a post into a feed.
 *
 * @param {Object} post - The post data.
 * @param {HTMLElement} feed_parent_list - The parent list where the post will be inserted.
 * @param {boolean} locked - Indicates whether the post is locked / should not be moved.
 */
function insert_feed_divider(text, feed_parent_list, locked) {
  const post_list_item = document.createElement("li");
  post_list_item.className = `border mt-2 post${
    locked ? " static" : ""
  } rounded`;
  post_list_item.style =  `background-color: rgb(${0}, ${0}, ${0})`;
  post_list_item.innerHTML = `
  <div class="d-flex flex-row justify-content-between align-items-center p-1">
    <div class="d-flex flex-row align-items-center feed-text px-2">
      <div class="d-flex flex-column flex-wrap ml-2">
        <span class="font-weight-bold" style="color: #FFFFFF">${text}</span>
      </div>
    </div>
  </div>
`;
  // console.log(post);

  feed_parent_list.appendChild(post_list_item);
}

/**
 * Inserts a post into a feed.
 *
 * @param {Object} post - The post data.
 * @param {HTMLElement} feed_parent_list - The parent list where the post will be inserted.
 * @param {boolean} locked - Indicates whether the post is locked / should not be moved.
 */
function insert_post(post, feed_parent_list, locked, divide=false) {
  const post_list_item = document.createElement("li");
  post_list_item.className = `border mt-2 post${
    locked ? " static" : ""
  } rounded`;
  let rgb = string_to_rgb(post.author_name);

  if (post.attn_1 || post.attn_2|| post.attn_3||post.attn_4 ||post.attn_5) {
    post.text = "";
    post.author_name = "";
    rgb = [0,0,0];
    for (const key in feature_dict) {
      post[key] = null;
    }
  } 
  if (post.attn_1) {
    // var color = post["correct_position"] * 150 + 50
    // post_list_item.style =  `background-color: rgb(${color}, ${color}, ${color})`;
    var incorrect = post["correct_position"];
    if (!incorrect) {
      post.text = "15"
    } else {
      post.text = "14"
    }
  }
 
  if (post.attn_2) {
    var incorrect = post["correct_position"];
    if (!incorrect) {
      post.text = "The sky is blue because it is sunny today."
    } else {
      post.text = "The sky is red because it is sunny today."
    }
  }

  // if (post.attn_1) {
  //   // var color = post["correct_position"] * 150 + 50
  //   // post_list_item.style =  `background-color: rgb(${color}, ${color}, ${color})`;
  //   var incorrect = post["correct_position"];
  //   if (!incorrect) {
  //     post.text = "My favorite politician is RFK Jr. "
  //   } else {
  //     post.text = "I'm watching the RNC right now"
  //   }
  // }
 
  // if (post.attn_2) {
  //   var incorrect = post["correct_position"];
  //   if (!incorrect) {
  //     post.text = "I think the USA needs a female president. We've had 45 guys so I think it's high time for a woman. Let's go Kamala! I'm voting for her."
  //   } else {
  //     post.text = "This country is falling apart and the two party system is to blame."
  //   }
  // }

  if (post.attn_3) {
    var incorrect = post["correct_position"];
    if (!incorrect) {
      post.text = "My friend just bought me a gorgeous new dress. It's so summery and flouncy, perfect for wearing in hot weather!"
    } else {
      post.text = "I want to go home already. My day was long and I need sleep, so it would be nice if I didn't have 10 more emails to send. Ugh... can anyone relate?"
    }
  }

  if (post.attn_4) {
    var incorrect = post["correct_position"];
    if (!incorrect) {
      post.text = "Happy mothers day! I really appreciate my mother for all she did for me. I owe her a lot and hope she knows it"
    } else {
      post.text = "I called my sister today and she hung up on me immediately. Politics are ruining our relationships."
    }
  }

  if (post.attn_5) {
    var incorrect = post["correct_position"];
    if (!incorrect) {
      post.text = "When deciding how to vote, you should start by reading each candidate's platform. You should discuss your opinions with others in your community to understand what issues affect them. Also, you shouldn't forget to make sure you are registered."
    } else {
      post.text = "Your opinions suck! Mine, on the other hand, are always very intelligent and reasonable. Be more like me :)"
    }
  }
  
  if(divide) {
    insert_feed_divider("Posts below this point would be ranked so low that, in a typical social media feed, it is unlikely they would ever be seen", feed_parent_list, locked);
  }

  let highlighted_feature = post.highlighted_feature;

  post_list_item.innerHTML = `
  <div class="d-flex flex-row justify-content-between align-items-center p-1 border-bottom">
    <div class="d-flex flex-row align-items-center feed-text px-2">
      <div style="width: 30px; height: 30px; border-radius: 50%; background-color: rgb(${
        rgb[0]
      }, ${rgb[1]}, ${rgb[2]});"></div>
      <div class="d-flex flex-column flex-wrap ml-2">
        <span class="font-weight-bold author-name">${post.author_name}</span>
      </div>
    </div>
    <div class="feed-icon px-2"><i class="fa fa-ellipsis-v text-black-50"></i></div>
  </div>
  <div class="p-1 px-1">
    <span class="small-text post_text
    ${highlighted_feature === "text" ? " highlighted-text" : ""}">${
    post.text
  }</span>
  </div>
  <div class="d-flex justify-content-between p-1 py-1">
    ${Object.keys(feature_dict)
      .map(
        (key) => `
      <div class="${key} p-1 px-1">
        <i class="${FEATURE_ICON_DICT[key]}"></i>
        ${
          (post[key] != null)
            ? `<span class="count${
                highlighted_feature === key ? " highlighted" : ""
              }">${format_number_for_display(post[key])} ${feature_dict[key]}</span>`
            : "--"
        }
      </div>`
      )
      .join("")}
  </div>
`;
  // console.log(post);
  post_list_item.setAttribute("data-number", post.correct_index ?? -1);

  feed_parent_list.appendChild(post_list_item);
}

/**
 * Inserts a feed into a container with an option to toggle visibility of posts.
 *
 * @param {Array} feed_data - The data for the feed.
 * @param {HTMLElement} container - The container where the feed will be inserted.
 * @param {number} feed_width - The width of the feed container.
 * @param {number} starting_num_posts - The number of initial posts to display.
 * @param {boolean} is_locked - Indicates whether the feed is locked in place.
 */
function insert_feed(
  feed_data,
  container,
  feed_width,
  starting_num_posts,
  is_locked, 
  exposure = false
) {

  const feed_bank_container = document.createElement("div");
  feed_bank_container.className = `col-md-${feed_width} p-md-1`;

  const feed_parent_ul = document.createElement("ul");
  feed_parent_ul.className = `feed sortable${
    is_locked ? " locked" : ""
  } feed-list-bank list-unstyled`;

  let indicies;
  if (bucketing) {
    indicies = get_random_sample_indices_from_chunks(feed_data, starting_num_posts);
    // TODO: this is where we should take two

  }

  // console.log(container.id)
  let barrier = Math.floor(feed_data.length / 2)


  for (let i = 0; i < feed_data.length; i++) {
    var divide = false;
    if (exposure && i == barrier) {
      divide = true;
    }
    insert_post(feed_data[i], feed_parent_ul, is_locked, divide);

    // TODO: okay so we need to check if the "Index" of the post is in indicies or not
    if (bucketing) {
      if (indicies.indexOf(feed_data[i]["Index"]) == -1 && container.id != "intro-post" && exposure) {
        feed_parent_ul.lastChild.style.display = "none";
        // This makes the posts that aren't displayed blue
        feed_parent_ul.lastElementChild.classList.add("second-static");
      } else if (exposure) {
        feed_parent_ul.lastChild.style.display = "block";
      }
    } else {
      if (i >= starting_num_posts) {
        feed_parent_ul.lastChild.style.display = "none";
        feed_parent_ul.lastElementChild.classList.add("static");
      }
    }
  }

  if (exposure) {
    var exposureDiv = document.getElementById('exposure-bar');
    exposureDiv.style.display = "block";
    feed_parent_ul.setAttribute('id', 'feed-parent-ul');
    feed_bank_container.appendChild(feed_parent_ul);
    exposureDiv.appendChild(feed_bank_container)
    // container.appendChild(feed_bank_container);
  }
  else {
    feed_bank_container.appendChild(feed_parent_ul);
    container.appendChild(feed_bank_container);
  }
  

}

/**
 * Populates a feed container with feeds and a functioning "Load More" button at the bottom.
 *
 * @param {Array} feeds - The feeds to be inserted.
 * @param {HTMLElement} container - The container for feeds and the "Load More" button.
 * @param {boolean} labeled - Indicates whether labels are added.
 * @param {number} starting_num_posts - The number of initial posts to display for each feed.
 * @param {number} num_posts_to_load - The number of posts to toggle visibility for on each "Load More" click for each feed.
 */
function populate_feed_container(
  feeds,
  container,
  labels,
  starting_num_posts,
  num_posts_to_load, 
  exposure = false
) {
  const feed_width = Math.floor(12 / feeds.length);
  const label_width = feed_width;

  const label_row = document.createElement("div");
  label_row.className = "row label-container align-items-start pl-1 pr-3 pb-1";
  container.appendChild(label_row);

  const feed_row = document.createElement("div");
  feed_row.className = "row feed-scroll visible-scrollbar";

  const load_more_button = document.getElementById('load-more-button') //document.createElement("button");
  if (load_more_button){
    if (bucketing) {
      load_more_button.innerText = "Insert More Posts into Current Feed";
    }
    else {
      load_more_button.innerText = "Add More Posts to Feed";
    }
    load_more_button.className = "load-more-button btn btn-light btn-block mt-1";
    load_more_button.style.backgroundColor = "#dcecfa";
  
    // AKA if this isn't exposure
    if (starting_num_posts >= feeds[0].length) {
      load_more_button.style.display = "none";
    }
  }
  

  // Change made on June 3rd by Helena -- Now the button is in the other sidebar 
  // feed_row.appendChild(load_more_button);

  for (let i = 0; i < feeds.length; i++) {
    if (labels.length > 0) {
      let label_text = labels[i];
      insert_label(label_text, label_row, label_width);
    }

    const feed_data = feeds[i];
    insert_feed(feed_data, feed_row, feed_width, starting_num_posts, true, exposure);
  }
  if (!exposure) {
    container.appendChild(feed_row);
  }
  

  
  if (load_more_button){
    load_more_button.addEventListener("click", () => {
      const feed_row_exposure = document.getElementById('exposure-bar');
      const feed_containers = feed_row_exposure.querySelectorAll(".feed-list-bank");
      let button_hidden = true;

      for (let i = 0; i < feed_containers.length; i++) {
        const feed_container = feed_containers[i];
        const all_posts = feed_container.children;

        if (bucketing) {
          var current_posts = []
          for (let i = 0; i < all_posts.length; i++) {
            if (all_posts[i].style.display == "block") {
              current_posts.push(i);
              if (all_posts[i].classList.contains("second-static")) {
                all_posts[i].classList.remove("second-static"); 
                all_posts[i].classList.add("static"); 
                }          
            }
            // TODO: maybe add second static here? or do it when they get added  
          }
          // NOTE: the posts in current posts are of a different type than those in the data/ available library of posts
          let indicies_plus = get_random_sample_indices_from_chunks(feeds[i], num_posts_to_load + current_posts.length);
          const indicies = indicies_plus.filter(
            (index) =>
              !current_posts.some((current_post) => isEqual(current_post, index))
          ).sort(() => .5 - Math.random()).slice(0, num_posts_to_load);
          for (let j = 0; j < all_posts.length; j++) {
            //TODO: this may have an issue in the case that the very last index is called
            if (typeof feeds[i][j] !== 'undefined' && (indicies.indexOf(feeds[i][j]["Index"]) != -1 || set_posts)) {
              all_posts[j].style.display = "block";
            }
          }

          let count = 0;
          for (let j = 0; j < all_posts.length; j++) {
            if (all_posts[j].style.display == "block") {
              count++;
            }
          }
          if (count > all_posts.length - 2) {
            button_hidden = true;
          } else {
            button_hidden = false;
          }
        }
        else {
          let posts_to_show = num_posts_to_load;

          let start_index = 0;
          for (let j = 0; j < all_posts.length; j++) {
            if (all_posts[j].style.display === "none") {
              start_index = j;
              break;
            }
          }
          for (let j = start_index; j < all_posts.length; j++) {
            if (posts_to_show > 0 && all_posts[j].style.display === "none") {
              all_posts[j].style.display = "block";
              posts_to_show--;
            }
          }

          if (
            all_posts.length > 0 &&
            all_posts[all_posts.length - 1].style.display === "none"
          ) {
            button_hidden = false;
          }
        }
      }

      if (button_hidden) {
        load_more_button.style.display = "none";
      }
    });
  }
}

/**
 * Inserts markdown text into a container.
 *
 * @param {string} markdown - The text to be inserted.
 * @param {HTMLElement} entry_div - The container where the text will be inserted.
 */
function insert_markdown(markdown, entry_div) {
  const text_div = document.createElement("div");
  text_div.className = "pr-3";

  text_div.innerHTML = marked.parse(markdown);

  text_div.style.fontSize = "1.2em";

  entry_div.appendChild(text_div);
}

function insert_exposure_btn(entry_div) {
  const btn_div = document.createElement("div");
  btn_div.innerHTML = `<button type="button" class="btn btn-primary" id="exposure-btn" onclick="see_feed_again()" style='display: block'>See Feed Again</button>
  `;
  entry_div.appendChild(btn_div);
}

/**
 * Inserts a multiple-choice question into a container.
 *
 * @param {Object} question - The multiple-choice question data.
 * @param {HTMLElement} container - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_mcq(question, container, question_id) {
  const question_div = document.createElement("div");
  question_div.className = "form-question mb-2 mr-3 rounded";
  question_div.id = `${question_id}`;


  for (let i = 0; i < question.options.length; i++) {
    const radio_div = document.createElement("div");
    const radio_input = document.createElement("input");
    const radio_label = document.createElement("label");

    radio_div.className = "form-check mt-2";
    radio_input.className = "form-check-input";
    radio_label.className = "form-check-label";
    radio_label.style.display = "inline-block";
    radio_label.style.paddingLeft = "25px";
    radio_label.style.marginLeft = "-25px";

    radio_input.type = "radio";
    radio_input.name = `question_${question_id}`;
    radio_input.value = question.option_key[i];
    radio_input.id = `${container.id}_${question.options[i]
      .replace(/\s+/g, "_")
      .toLowerCase()}`;

    radio_label.for = radio_input.id;
    radio_label.textContent = question.options[i];


    radio_div.appendChild(radio_input);
    radio_div.appendChild(radio_label);

    question_div.appendChild(radio_div);

    radio_label.addEventListener("click", () => {
      radio_input.checked = true;
    });
  }

  container.appendChild(question_div);
}

function insert_slider(question, container, question_id) {
  const question_div = document.createElement("div");
  question_div.className = "slide-question";
  question_div.id = `${question_id}`;

  var val = 50;

  const slider_id = `slider_${question_id}`;
  const value_id = `rangeValue_${question_id}`
  const fn = `rangeValue_feedback_1.innerText = this.value`;
  // const fn = "console.log(this.value)";

  // const slider_label_l = document.createElement("label");
  // slider_label_l.for = "left-side";
  // slider_label_l.className = `float-left mr-5`
  // slider_label_l.innerText = question.options[0];
  // const slider_input = document.createElement("input");
  // slider_input.id = `slider-${question_id}`;
  // slider_input.type = "range";
  // slider_input.className = "slider mt-10";
  // const slider_label_r = document.createElement("label");
  // slider_label_r.for = "right-side";
  // slider_label_r.className = `ml-5`
  // slider_label_r.innerText = question.options[1];
  // const slider_value = document.createElement("p");
  // slider_value.id = `rangeValue-${question_id}`;
  // slider_value.innerText
  // slider_input.oninput = `console.log(this.value)`


  // const slider_div = document.createElement("form");
  question_div.innerHTML = `
  <label for="left-side" class="float-left mr-5">${question.options[0]}</label>
  <input id=${slider_id} class="slider mt-10" type="range" min="0" max="100" value="50" step="5"
        oninput="this.nextElementSibling.nextElementSibling.innerText = this.value">
  <label for="right-side" class="ml-5">${question.options[1]}</label>
        <p id=${value_id}>50%</p>  
  `

  container.appendChild(question_div);
}

/**
 * Inserts radio buttons for a question into a container.
 *
 * @param {Object} question - The question data.
 * @param {HTMLElement} body_div - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_radio_buttons(question, body_div, question_id) {
  const question_div = document.createElement("div");
  question_div.className = "form-question pl-2 mb-2 mr-3 rounded";
  question_div.id = `${question_id}`;

  insert_markdown(question.text, question_div);

  const radio_buttons_row = document.createElement("div");
  radio_buttons_row.className = "radio-buttons-row mt-2";
  radio_buttons_row.style.display = "flex";
  radio_buttons_row.style.justifyContent = "between";

  question_div.appendChild(radio_buttons_row);

  let selected_button = null;

  const available_width = body_div.offsetWidth / question.options.length;

  const min_length = question.options.reduce((min, current) => {
    return current.length < min ? current.length : min;
  }, question.options[0].length);

  for (let i = 0; i < question.options.length; i++) {
    const radio_button = document.createElement("button");

    radio_button.className =
      "btn btn-outline-primary mr-1 pt-2 d-flex justify-content-center align-items-center";
    radio_button.type = "button";

    const adjusted_width = available_width * 0.9;
    radio_button.style.width = `${adjusted_width}px`;

    radio_button.style.width = `${90 / question.options.length}%`;

    radio_button.addEventListener("click", () => {
      const selected_radio = radio_button.querySelector("input[type='radio']");
      selected_radio.checked = true;

      if (selected_button) {
        selected_button.classList.remove("btn-primary");
        selected_button
          .querySelector("label")
          .classList.remove("selected-label");
      }

      radio_button.classList.add("btn-primary");
      selected_button = radio_button;
      selected_button.querySelector("label").classList.add("selected-label");

      radio_button.blur();
    });

    const radio_input = document.createElement("input");
    radio_input.type = "radio";
    radio_input.name = `question_${question_id}`;
    radio_input.value = question["option-key"][i];
    radio_input.id = `${body_div.id}_${question.options[i]
      .replace(/\s+/g, "_")
      .toLowerCase()}`;
    radio_input.style.display = "none";

    const radio_label = document.createElement("label");
    radio_label.for = radio_input.id;
    radio_label.textContent = question.options[i];

    const max_font_size = (100 * Math.sqrt(6)) / min_length;

    radio_label.style.fontSize = `${max_font_size}px`;

    radio_label.classList.add(
      "d-flex",
      "justify-content-center",
      "align-items-center"
    );

    radio_button.appendChild(radio_input);
    radio_button.appendChild(radio_label);
    radio_buttons_row.appendChild(radio_button);
  }

  body_div.appendChild(question_div);
}

/**
 * Inserts checkboxes for a question into a container.
 *
 * @param {Object} question - The question data.
 * @param {HTMLElement} container - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_checkbox(question, container, question_id) {
  const question_div = document.createElement("div");
  question_div.className = "form-question mb-4 rounded";
  question_div.id = `${question_id}`;

  insert_markdown(question.text, question_div);

  for (let i = 0; i < question.options.length; i++) {
    const checkbox_div = document.createElement("div");
    const checkbox_input = document.createElement("input");
    const checkbox_label = document.createElement("label");

    checkbox_div.className = "form-check mt-2";
    checkbox_input.className = "form-check-input";
    checkbox_label.className = "form-check-label";

    checkbox_input.type = "checkbox";
    checkbox_input.name = `question_${container.id}`;
    checkbox_input.value = question["option-key"][i];
    checkbox_input.id = `${container.id}_${question.options[i]
      .replace(/\s+/g, "_")
      .toLowerCase()}`;

    checkbox_label.for = checkbox_input.id;
    checkbox_label.textContent = question.options[i];

    checkbox_div.appendChild(checkbox_input);
    checkbox_div.appendChild(checkbox_label);
    question_div.appendChild(checkbox_div);
  }

  container.appendChild(question_div);
}

/**
 * Inserts a post placement question into a container.
 *
 * @param {Object} question - The question data.
 * @param {HTMLElement} container - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_post_bank(entry, entry_div, question_id, is_practice=false) {
  entry_div.className = "post-bank-question mb-3 mr-3 rounded";
  entry_div.id = `${question_id}`;
  // const label_div = document.createElement("div");
  // label_div.className = `col-${label_width} d-flex align-items-center justify-content-center`;
  // label_div.innerHTML = `<button type="button" class="btn btn-primary" id="exposure-btn" onclick="see_feed_again()" style='display: none'>See Feed Again</button>
  // <br><br>`;
  // label_container.appendChild(label_div);

  insert_feed(entry.post_bank, entry_div, 12, entry.post_bank.length, false);
}

/**
 * Inserts a text input question into a container.
 *
 * @param {Object} entry - The question data.
 * @param {HTMLElement} entry_div - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_text_input(entry, entry_div, question_id) {
  const question_div = document.createElement("div");
  question_div.className = "text-question mb-2 mr-3 rounded";
  question_div.id = `${question_id}`;

  const text_input = document.createElement("textarea");
  text_input.setAttribute("rows", "4");
  text_input.style.width = "100%";

  question_div.appendChild(text_input);
  entry_div.appendChild(question_div);
}

/**
 * Inserts a question into a container.
 *
 * @param {Object} entry - The question data.
 * @param {HTMLElement} body_div - The container where the question will be inserted.
 * @param {string} question_id - The screen name.
 */
function insert_entry(entry, body_div, question_id) {
  const entry_div = document.createElement("div");

  if (entry.hasOwnProperty("markdown")) {
    insert_markdown(entry.markdown, entry_div);
  } 
  if (entry.hasOwnProperty("exposure_btn")) {
    insert_exposure_btn(entry_div);
  }

  if (entry.hasOwnProperty("answer_area")) {
    switch (entry.answer_area) {
      case "multiple_choice":
        insert_mcq(entry, entry_div, question_id);
        break;
      case "slider":
        insert_slider(entry, entry_div, question_id);
        break;
      case "radio_buttons":
        insert_radio_buttons(entry, entry_div, question_id);
        break;
      case "checkbox":
        insert_checkbox(entry, entry_div, question_id);
        break;
      case "post_bank":
        insert_post_bank(entry, entry_div, question_id);
        break;
      case "text_input":
        insert_text_input(entry, entry_div, question_id);
        break;
      default:
        console.log(`Error: ${entry.answer_area} is not a valid answer area`);
    }
  }

  body_div.appendChild(entry_div);

  if (entry.includes_confidence) {
    const confidence_div = document.createElement("div");
    insert_markdown(
      `How confident are you in your answer to the above?`,
      confidence_div
    );
    insert_radio_buttons(
      {
        text: "",
        options: [
          "Not at all confident",
          "Slightly confident",
          "Somewhat confident",
          "Fairly confident",
          "Completely confident",
        ],
        "option-key": [-2, -1, 0, 1, 2],
      },
      confidence_div,
      question_id + "-CF",
      "confidence"
    );

    body_div.appendChild(confidence_div);
  }
}

/**
 * Populates a questions container with various question types.
 *
 * @param {Object} entries - The questions to be inserted.
 * @param {HTMLElement} container - The container for questions.
 * @param {string} screen_name - The screen name.
 */
function insert_entries(entries, body_div, screen_name) {
  // loop over each entry and give it an id of '${screen_name}_${index}'
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    const question_id = `${screen_name}_${i}`;

    insert_entry(entry, body_div, question_id);
  }

  redact_items(redacted_classes);
}
    /**
 * Activates the next screen.
 *
 * @param {Object} screen_info - The screen info object.
 * @param {string} section_name - The name of the section.
 */
function display_screen(screen_info, section_name) {
  let screen_name = generate_screen_name(screen_info);

  let screen_title = document.getElementById("screen-title");
  screen_title.innerHTML =
    section_name.charAt(0).toUpperCase() + section_name.replace(/_/g, ' ').slice(1);

  let top_bar = document.getElementById("top-bar");
  top_bar.style.backgroundColor =
    SECTION_COLORS[section_name] || SECTION_COLORS.default;

  let question_progress = document.getElementById("question-progress");
  if (question_screens.includes(screen_info.screen_type)) {
    question_progress.innerHTML = `Question ${curr_screen_index + 1} of ${
      study_array[curr_section_index].screens.length
    }`;
  } else {
    question_progress.innerHTML = `Page ${curr_screen_index + 1} of ${
      study_array[curr_section_index].screens.length
    }`;
  }

  if (!screen_info) {
    console.error("Screen name " + screen_name + " is undefined");
    return;
  }
  if (screen_info.is_practice) {
    $('#exposure-btn').css('display', 'inline-block')
  } else {
    $('#exposure-btn').css('display', 'none')
  }

  let template_id = screen_info.template_id;
  if (template_id === "feed-and-sidebar") {
    populate_fs_screen(screen_info, screen_name);
  } else if (template_id === "submission") {
    document.getElementById("next-btn").style.display = "none";
  } else if (template_id === "centered-content") {
    populate_cc_screen(screen_info);
  } else {
    let intro_post = source_posts[0];
    insert_feed(
      [intro_post],
      document.getElementById("intro-post"),
      12,
      1,
      1,
      false
    );
  }
  document.getElementById(template_id).style.display = "block";
  redact_items(redacted_classes);
  window.scrollTo(0, 0);
}
    /**
 * Populates the screen with feeds and sidebar entries based on the provided screen information.
 *
 * @param {Object} screen_info - The screen information object.
 * @param {string} screen_name - The name of the screen.
 */
function populate_fs_screen(screen_info, screen_name) {
  const screen_type = screen_info.screen_type;
  var sidebar_entries = screen_info.sidebar_entries;
  let feeds = deep_copy(screen_info["feeds"]);
  let num_feeds = feeds.length;
  const display_unit_width = Math.min(12 / (num_feeds + 1), num_feeds * 5);
  const feed_column_width = Math.floor(display_unit_width * feeds.length);
  const sidebar_column_width = Math.ceil(display_unit_width);

  //Helena commented this out on May 28,2024
  // This code was making it such that the HTML wasn't working and removing all the classes
  // if (feeds.length > 0) {
  //   $("#FS-feed-container")
  //     .removeClass(function (index, className) {
  //       return (className.match(/\bcol-md-\S+/g) || []).join(" ");
  //     })
  //     .addClass(`col-md-${feed_column_width}`);

  //   $("#FS-sidebar")
  //     .removeClass(function (index, className) {
  //       return (className.match(/\bcol-md-\S+/g) || []).join(" ");
  //     })
  //     .addClass(`col-md-${sidebar_column_width}`);
  // }
  $('#right-btn-cntr').css('display', 'none')
  $('#wrong-btn-cntr').css('display', 'none')
  $('#next-btn').css('display', 'inline-block')

  let labeled = true;

  if (screen_type == "feed_selection") {
    labeled = true;
    let correct_feed_idx = screen_info["correct_feed_index"];
    sidebar_entries["Q1"]["options"] = Array.from(
      { length: feeds.length },
      (value, index) => "Feed " + String.fromCharCode(65 + index)
    );
    sidebar_entries["Q1"]["option_key"] = Array.from(
      { length: feeds.length },
      (value, index) => (index === correct_feed_idx ? 1 : 0)
    );
  } else if (screen_type == "post_placement") {
    if (screen_info.is_practice) {
      sidebar_entries[0]["exposure_btn"] = true;
    }
    // labeled = false;
    // let question_feed = [screen_info["extracted_post"]];
    // sidebar_entries["Q1"]["feed"] = question_feed;
  }

  insert_entries(
    sidebar_entries,
    document.getElementById("FS-sidebar"),
    screen_name
  );

  if (feeds.length > 0) {
    if (screen_name == "exposure") {
      populate_feed_container(
        feeds,
        document.getElementById("exposure-bar"),
        screen_info["labels"] ?? [],
        screen_info["starting_num_posts"],
        screen_info["num_posts_to_load"], 
        true
      );

    } else {
      populate_feed_container(
        feeds,
        document.getElementById("FS-feeds"),
        screen_info["labels"] ?? [],
        screen_info["starting_num_posts"],
        screen_info["num_posts_to_load"]
      );
    }
  }

  if (screen_type == "correct_response") {
    $(".feed").addClass("locked");
    $(".post").addClass("static");
  } else {
    $('#feed-parent-ul').removeClass('sortable')
    $(".sortable").sortable({
      connectWith: ".sortable",
      items: "li:not(.unmoveable, .exposure-posts)",
      cancel: ".static, .second-static",
      scroll: true,
      zIndex: 9999,
      appendTo: $(".feed").not(".locked"),
    });
  }
}
    function populate_cc_screen(screen_info) {
  let body_element = document.getElementById("CC-body");
  insert_entries(screen_info.entries, body_element, "feedback");
}

    /**
 * Processes a checked question and updates the screen output.
 *
 * @param {Element} question_div - The question div element.
 * @param {Object} screen_output - The screen output object.
 * @param {Object} unanswered_questions - Object to track unanswered questions.
 * @param {Object} incorrect_questions - Object to track incorrect questions.
 */
function process_choice_question(
  question_div,
  screen_output,
  unanswered_questions,
  incorrect_questions
) {
  const question_id = question_div.id;
  const inputs = question_div.querySelectorAll("input");
  const checked_inputs = question_div.querySelectorAll("input:checked");
  const unchecked_inputs = question_div.querySelectorAll("input:not(:checked)");

  const chosen_answers = [];
  const correct_answers = [];
  let score = 0;

  for (let i = 0; i < checked_inputs.length; i++) {
    const checked_input = checked_inputs[i];
    const option_text = checked_input.nextElementSibling.textContent;
    chosen_answers.push(option_text);
    const option_value = parseFloat(checked_input.value);
    score += option_value;
  }

  // if (question_id.slice(-2) !== "CF") {
  //   for (let i = 0; i < unchecked_inputs.length; i++) {
  //     const unchecked_input = unchecked_inputs[i];
  //     const option_value = parseFloat(unchecked_input.value);
  //     score += isNaN(option_value) ? 0 : option_value < 0 ? -option_value : 0;
  //   }
  // }

  for (let i = 0; i < inputs.length; i++) {
    const input = inputs[i];
    const option_text = input.nextElementSibling.textContent;
    const option_value = parseFloat(input.value);

    if (option_value > 0) {
      correct_answers.push(option_text);
    }
  }

  const question = {
    question_type: "multiple_choice",
    correct_answers: correct_answers,
    chosen_answers: chosen_answers,
  };

  if (chosen_answers.length === 0) {
    unanswered_questions[question_div.id] = question;
  } else if (
    chosen_answers.length !== correct_answers.length ||
    !chosen_answers.every((value, index) => value === correct_answers[index])
  ) {
    incorrect_questions[question_div.id] = question;
  }

  if (question_id.slice(-2) === "CF") {
    screen_output["chosen_confidence"] = chosen_answers[0];
    screen_output["confidence"] = score;
  } else {
    const question_num = question_id.slice(-1);
    screen_output["chosen_options_" + question_num] = chosen_answers;
    screen_output["score_Q" + question_num] = score;
  }
}

/**
 * Processes a slider question and updates the screen output.
 *
 * @param {Element} question_div - The question div element.
 * @param {Object} screen_output - The screen output object.
 * @param {Object} unanswered_questions - Object to track unanswered questions.
 * @param {Object} incorrect_questions - Object to track incorrect questions.
 */
function process_slide_question(
  question_div,
  screen_output,
  unanswered_questions,
  incorrect_questions
) {
  const question_id = question_div.id;
  const slider_value = question_div.querySelector(`#rangeValue_${question_id}`).innerText;
  const user_input = Number(slider_value)

  const question = {
    question_type: "slide_input",
    correct_answers: null,
    chosen_answers: user_input,
  };

  if (slider_value === "50%") {
    unanswered_questions[question_id] = question;
  }

  screen_output["slider_input_" + question_id] = user_input;
}

/**
 * Processes a post placement question and updates the screen output.
 *
 * @param {Element} question_div - The question div element.
 * @param {Object} screen_output - The screen output object.
 * @param {Object} unanswered_questions - Object to track unanswered questions.
 * @param {Object} incorrect_questions - Object to track incorrect questions.
 * @param {Element} feed_ul - The feed element.
 * @param {Object} screen_info - screen info object
 */
function process_post_placement_question(
  question_div,
  screen_output,
  unanswered_questions,
  incorrect_questions,
  feed_ul,
  screen_info
) {
  const posts = feed_ul.querySelectorAll("li");
  const index_1 = screen_info.correct_posts[0]["full_index"];
  const index_2 = screen_info.correct_posts[1]["full_index"];
  const chunk_1 = screen_info.correct_posts[0]["Chunk"];
  const chunk_2 = screen_info.correct_posts[1]["Chunk"];


  let chosen_index = -1;
  let correct_index = -1;
  let distance = -1;

  // Lindsay: I'm not convinced that this works for a question where multiple posts are placed
  for (let i = 0; i < posts.length; i++) {
    const post = posts[i];
    const position = parseInt(post.dataset.number);
    if (position >= 0) {
      distance = Math.abs(i - position);
      correct_index = position;
      chosen_index = i;
      break;
    }
  }

  const question = {
    question_type: "post_placement",
    correct_answers: [correct_index],
    chosen_answers: [chosen_index],
  };
  if (chosen_index === -1) {
    unanswered_questions[question_div.id] = question;
  } else if (distance > 0) {
    incorrect_questions[question_div.id] = question;
  }

  screen_output["chosen_index"] = chosen_index;
  screen_output["correct_index"] = correct_index;
  screen_output["distance"] = distance;
  screen_output["score_Q1"] = distance === 0 ? 1 : 0;
  screen_output["index_1"] = index_1;
  screen_output["index_2"] = index_2;
  screen_output["chunk_1"] = chunk_1;
  screen_output["chunk_2"] = chunk_2;
}

/**
 * Processes a post arrangement question and updates the screen output.
 *
 * @param {Element} question_div - The question div element.
 * @param {Object} screen_output - The screen output object.
 * @param {Object} unanswered_questions - Object to track unanswered questions.
 * @param {Object} incorrect_questions - Object to track incorrect questions.
 * @param {Element} feed_ul - The feed element.
 */
function process_post_arrangement_question(
  question_div,
  screen_output,
  unanswered_questions,
  incorrect_questions,
  feed_ul
) {
  const posts = feed_ul.querySelectorAll("li");

  const response_ordering = [];
  let some_incorrect = false;

  for (let i = 0; i < posts.length; i++) {
    const post = posts[i];
    const position = post.getAttribute("data-number");

    response_ordering.push(position);

    if (i !== position) {
      some_incorrect = true;
    }
  }

  screen_output["response_ordering"] = response_ordering;
  // TODO: may need to redo logic to check if correct order
  screen_output["score_Q1"] = response_ordering.every(
    (val, i, arr) => i === 0 || val > arr[i - 1]
  )
    ? 1
    : 0;

  const question = {
    question_type: "post_arrangement",
    correct_answers: null,
    chosen_answers: response_ordering,
  };

  const incomplete_posts = question_div.querySelectorAll("li");

  if (incomplete_posts.length > 0) {
    unanswered_questions[question_div.id] = question;
  } else if (some_incorrect) {
    incorrect_questions[question_div.id] = question;
  }
}

/**
 * Processes a text input question and updates the screen output.
 *
 * @param {Element} question_div - The question div element.
 * @param {Object} screen_output - The screen output object.
 * @param {Object} unanswered_questions - Object to track unanswered questions.
 */
function process_text_input_question(
  question_div,
  screen_output,
  unanswered_questions
) {
  const question_id = question_div.id;
  const textarea = question_div.querySelector("textarea");
  const user_input = textarea.value.trim();

  const question = {
    question_type: "text_input",
    correct_answers: null,
    chosen_answers: user_input,
  };

  if (user_input === "") {
    unanswered_questions[question_id] = question;
  }

  screen_output["text_input_" + question_id] = user_input;
}

/**
 * Logs checked answers with sum and updates the screen output.
 *
 * @param {Object} screen_info - The screen info object.
 * @param {string} screen_name - The screen name.
 * @returns {Array} - Array containing screen output, unanswered questions, and incorrect questions.
 */
function get_screen_results(screen_info, screen_name) {
  const choice_questions = document.getElementsByClassName("form-question");
  const slide_questions = document.getElementsByClassName("slide-question");
  const post_bank_questions =
    document.getElementsByClassName("post-bank-question");
  const text_input_questions = Array.from(
    document.getElementsByClassName("text-question")
  );

  const feed_container = document.querySelector(".feed-container");
  const feed_elements = feed_container.querySelectorAll(".feed");

  const screen_output = {
    screen_type: screen_info.screen_type,
    feature_count: screen_info.feature_count,
    instance_number: screen_info.instance_number ?? 0,
    screen_name: screen_name,
  };

  const unanswered_questions = {};
  const incorrect_questions = {};

  for (let i = 0; i < choice_questions.length; i++) {
    process_choice_question(
      choice_questions[i],
      screen_output,
      unanswered_questions,
      incorrect_questions
    );
  }

  for (let i = 0; i < slide_questions.length; i++) {
    process_slide_question(
      slide_questions[i],
      screen_output,
      unanswered_questions,
      incorrect_questions
    );
  }

  for (let i = 0; i < post_bank_questions.length; i++) {
    if (screen_info.screen_type.includes("post_placement")) {
      process_post_placement_question(
        post_bank_questions[i],
        screen_output,
        unanswered_questions,
        incorrect_questions,
        feed_elements[i], 
        screen_info
      );
    } else {
      process_post_arrangement_question(
        post_bank_questions[i],
        screen_output,
        unanswered_questions,
        incorrect_questions,
        feed_elements[i]
      );
    }
  }

  text_input_questions.forEach((question) => {
    process_text_input_question(question, screen_output, unanswered_questions);
  });

  if (Object.keys(unanswered_questions).length === 0) {
    const question_outputs = output["questions"] ?? [];
    const screen_output_with_same_name = question_outputs.find(
      (output) => output["screen_name"] === screen_name
    );

    if (screen_output_with_same_name) {
      screen_output["screen_name"] = screen_name + "-REPEAT";
      screen_output["repeat"] = true;
    } else {
      screen_output["repeat"] = false;
    }
  }

  return [screen_output, unanswered_questions, incorrect_questions];
}

/**
 * Logs the screen results and returns unanswered and incorrect questions.
 *
 * @param {number} section_index - The index of the section.
 * @param {number} screen_index - The index of the screen.
 * @returns {Array} - Array containing unanswered questions and incorrect questions.
 */
function log_screen(section_index, screen_index) {
  const screen_info = study_array[section_index].screens[screen_index];

  const screen_name = generate_screen_name(screen_info);

  let unanswered_questions = {};
  let incorrect_questions = {};
  let screen_output = {};

  if (
    question_screens.includes(screen_info.screen_type) ||
    screen_info.screen_type.includes("feedback") || screen_info.screen_type == "post_exposure"
  ) {
    [screen_output, unanswered_questions, incorrect_questions] =
      get_screen_results(screen_info, screen_name);
  }

  if (Object.keys(unanswered_questions).length === 0) {
    screen_output["time_elapsed"] =
      (new Date().getTime() -
        study_array[section_index].screens[screen_index]["start_time"]) /
      1000;

    if (!screen_output.hasOwnProperty("screen_name")) {
      screen_output["screen_name"] = screen_name;
    }

    const section_name = study_array[section_index].section_name;

    if (!output[section_name]) {
      output[section_name] = [];
    }

    output[section_name].push(screen_output);
  }
  return [unanswered_questions, incorrect_questions];
}

/**
 * Logs the section results.
 *
 * @param {number} section_index - The index of the section.
 */
function log_section(section_index) {
  const section_name = study_array[section_index].section_name;
  const section_output = {
    section_name: section_name,
    time_elapsed:
      (new Date().getTime() - study_array[section_index]["start_time"]) / 1000,
  };

  output["global"].push(section_output);
}
    /**
 * Highlights unanswered and incorrect questions on the screen.
 *
 * @param {Object} unanswered_questions - Questions that are unanswered.
 * @param {Object} incorrect_questions - Questions that are answered incorrectly.
 */
function highlight_unanswered_questions(
  unanswered_questions,
  incorrect_questions
) {
  const question_divs = $(
    ".form-question, .post-bank-question, .text-question, .slide-question"
  );

  question_divs.each((i, question_div) => {
    if (unanswered_questions[question_div.id]) {
      question_div.setAttribute("data-state", "unanswered");
      question_div.style.border = "2px solid red";
      display_message(
        question_div,
        "red",
        "Please answer the required question."
      );
    } else if (incorrect_questions[question_div.id]) {
      question_div.setAttribute("data-state", "incorrect");
      question_div.style.border = "2px solid orange";
      display_message(
        question_div,
        "orange",
        answer_to_feedback(incorrect_questions[question_div.id])
      );
    } else {
      question_div.removeAttribute("data-state");
      question_div.style.border = "";
      remove_message(question_div);
    }
  });
}

/**
 * Generates a feedback message based on the answer type.
 *
 * @param {Object} answer - The answer object.
 * @returns {string} The feedback message.
 */
function answer_to_feedback(answer) {
  if (answer.question_type === "multiple-choice") {
    return `Your answer of "<strong>${array_to_string(
      answer.chosen_answers
    )}</strong>" was incorrect. The correct answer was "<strong>${array_to_string(
      answer.correct_answers
    )}</strong>". 
          Please correct your answer and try a new version of this question in the next screen.`;
  }

  if (answer.question_type === "post_placement") {
    return `Your placement of the post at position <strong>${
      answer.chosen_answers[0] + 1
    }</strong> is incorrect. Its correct position is <strong>${
      answer.correct_answers[0] + 1
    }</strong>.
          Please correct your answer and try a new version of this question in the next screen.`;
  }
}

/**
 * Displays a message on the screen.
 *
 * @param {HTMLElement} question_div - The question div element.
 * @param {string} color - The color of the message.
 * @param {string} message - The message to display.
 */
function display_message(question_div, color, message) {
  remove_message(question_div);

  const message_div = document.createElement("div");
  message_div.className = "message py-2";
  message_div.style.color = color;
  message_div.style.fontSize = "medium";
  message_div.style.textAlign = "center";
  message_div.innerHTML = message;
  question_div.appendChild(message_div);
}

/**
 * Removes a message from the screen.
 *
 * @param {HTMLElement} question_div - The question div element.
 */
function remove_message(question_div) {
  const message_div = question_div.querySelector(".message");
  if (message_div) {
    question_div.removeChild(message_div);
  }
}

/**
 * Increments the screen index.
 */
function increment_screen_index() {
  if (
    curr_screen_index === study_array[curr_section_index].screens.length - 1 &&
    curr_section_index < study_array.length - 1
  ) {
    curr_section_index++;
    curr_screen_index = 0;
  } else if (
    curr_section_index < study_array.length &&
    curr_screen_index < study_array[curr_section_index].screens.length - 1
  ) {
    curr_screen_index++;
  } else {
    console.error("No more screens to advance to");
  }
}

function give_feedback(curr_screen_info) {
  $('#next-btn').css('display', 'none');
  if (output.hasOwnProperty("practice")) {
    if (output["practice"][curr_screen_index]["correct_index"] === output["practice"][curr_screen_index]["chosen_index"]){
      $('#right-btn-cntr').css('display', 'inline-block')
    } else {
      $('#wrong-btn-cntr').css('display', 'inline-block')
    }
  } else if (output.hasOwnProperty("training")){
    if (output["training"][curr_screen_index]["screen_name"].includes("placement")) {
      if (output["training"][curr_screen_index]["correct_index"] === output["training"][curr_screen_index]["chosen_index"]){
        $('#right-btn-cntr').css('display', 'inline-block')
      } else {
        $('#wrong-btn-cntr').css('display', 'inline-block')
      }
    } else {
      if (output["training"][curr_screen_index]["score_Q1"] == 1) {
        $('#right-btn-cntr').css('display', 'inline-block')
      } else {
        $('#wrong-btn-cntr').css('display', 'inline-block')
      }
    }
    
  } 
  
}

/**
 * Proceeds to the next screen.
 */
function next_screen() {
  const curr_screen_info =
    study_array[curr_section_index].screens[curr_screen_index];

  var time_onscreen = (new Date().getTime() - curr_screen_info["start_time"]) /1000;
  if (curr_screen_info.screen_type === "exposure" && time_onscreen < 120) {
    alert(`Please look at the feed for at least 120 seconds. You have only spent ${time_onscreen} seconds so far`);
    return;
  }

  if (curr_screen_info.screen_type === "post_exposure" && time_onscreen < 60) {
    alert(`Please look at the feed for at least 60 seconds. You have only spent ${time_onscreen} seconds so far`);
    return;
  }

  if (
    question_screens.includes(curr_screen_info.screen_type) ||
    curr_screen_info.screen_type.includes("feedback") || curr_screen_info.screen_type === "post_exposure"
  ) {
    const is_practice = curr_screen_info.screen_type === "practice";

    let [_, unanswered_questions, incorrect_questions] = get_screen_results(
      curr_screen_info,
      generate_screen_name(curr_screen_info)
    );

    if (!is_practice) {
      incorrect_questions = {};
    }

    if (
      Object.keys(unanswered_questions).length > 0 ||
      Object.keys(incorrect_questions).length > 0
    ) {
      highlight_unanswered_questions(unanswered_questions, incorrect_questions);
      return;
    }
  }

  if ((curr_screen_info.screen_type.includes("post_placement") || curr_screen_info.screen_type.includes("exposure_intro")) && curr_screen_info.is_practice && $("#next-btn").css("display") != "none"){
    log_screen(curr_section_index, curr_screen_index);
    give_feedback(curr_screen_info);

    return;
    } 
  else if ((curr_screen_info.screen_type.includes("post_placement") || curr_screen_info.screen_type.includes("exposure_intro")) && curr_screen_info.is_practice && $("#next-btn").css("display") == "none") {
    // Nothing
  }
  else {
    log_screen(curr_section_index, curr_screen_index);
  }

  if (
    curr_screen_index ===
    study_array[curr_section_index].screens.length - 1
  ) {
    log_section(curr_section_index);
  }

  if (curr_screen_info.screen_type == "post_placement_check_2") {
    const sum = output["training"][0]["score_Q1"] + output["training"][1]["score_Q1"]; //+ output["training"][2]["score_Q1"] + output["training"][3]["score_Q1"] + output["training"][4]["score_Q1"];
    if (sum == 0) {
      // do nothing
    } else {
      increment_screen_index();
      output["training"][curr_screen_index] = {};
    }
  }
  increment_screen_index();



  const is_next_screen_correction =
    study_array[curr_section_index].screens[curr_screen_index].screen_type ===
    "correct_response";

  deactivate_screen(curr_screen_info.template_id, !is_next_screen_correction);

  if (curr_screen_index === 0) {
    study_array[curr_section_index]["start_time"] = new Date().getTime();
  }

  study_array[curr_section_index].screens[curr_screen_index]["start_time"] =
    new Date().getTime();

  display_screen(
    study_array[curr_section_index].screens[curr_screen_index],
    study_array[curr_section_index].section_name
  );
}

/**
 * Deactivates the current screen.
 *
 * @param {string} template_id - The template ID of the screen.
 * @param {boolean} empty_feed - Flag to indicate if the feed should be emptied.
 */
function deactivate_screen(template_id, empty_feed) {

  const curr_screen_info =
    study_array[curr_section_index].screens[curr_screen_index];

  var current_screen = curr_screen_info.screen_type

  if (current_screen != "exposure") {
    $('#exposure-bar').css('display', 'none')

    const feed_row_exposure = document.getElementById('exposure-bar');
    const feed_containers = feed_row_exposure.querySelectorAll(".feed-list-bank");
    for (let i = 0; i < feed_containers.length; i++) {
      const feed_container = feed_containers[i];
      const all_posts = feed_container.children;

      for (let i = 0; i < all_posts.length; i++) {
        if (all_posts[i].style.display == "block") {
          if (all_posts[i].classList.contains("static") || 
            all_posts[i].classList.contains("second-static")) {
            all_posts[i].classList.remove("static"); 
            all_posts[i].classList.remove("second-static"); 
            all_posts[i].classList.add("exposure-posts"); 
          }          
        }
      }
    }
  }

  $("#CC-body").empty();

  if (empty_feed) {
    $("#FS-feeds").empty();
  }

  $("#FS-sidebar").empty();

  window.scrollTo(0, 0);
  document.getElementById(template_id).style.display = "none";
}

/**
 * Redacts the specified class items.
 *
 * @param {string[]} class_names - The class names of the items to redact.
 */
function redact_items(class_names) {
  class_names.forEach((class_name) => {
    const items = document.getElementsByClassName(class_name);
    for (let i = 0; i < items.length; i++) {
      items[i].style.color = "gray";
      items[i].classList.add("redacted");
    }
  });
}

/**
 * Submits the current screen.
 */
function submit() {
  var filename = output["global"][2]["pid"] + ".json";
  let string_output = JSON.stringify(output);
  fetch("https://pipe.jspsych.org/api/data/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "*/*",
    },
    body: JSON.stringify({
      experimentID: "IO3THWV5EO6t",
      filename: filename,
      data: string_output,
    }),
  }).then(response => {
    window.location.href = 'https://app.prolific.com/submissions/complete?cc=CG717WJX';
    // window.location.href= "https://connect.cloudresearch.com/participant/project/F5FE3D364D/complete";
  })
  // window.location.href = 'https://app.prolific.com/submissions/complete?cc=CG717WJX';
  // proliferate.submit(output);
}

function see_feed_again() {
  if ($('#exposure-bar').css('display') == 'none') {
    $('#exposure-bar').css('display', 'inline-block')
    $('#feed-parent-ul').on('drop', function(event){
      return false;
    })
  } else {
    $('#exposure-bar').css('display', 'none')
  }
}

    /**
 * Sanitizes *generic* posts by modifying their text, author name, and other properties.
 *
 * @param {Object[]} generic_posts - The array of posts to sanitize.
 */
function sanitize_posts(generic_posts) {
  const placeholder_text =
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.";

  for (let i = 0; i < generic_posts.length; i++) {
    const post = generic_posts[i];

    // Truncate the post text to a random length
    const words = placeholder_text.split(" ");
    const random_word_count =
      Math.floor(Math.random() * (words.length - 20)) + 10;
    const truncated_text = words.slice(0, random_word_count).join(" ");
    post.text = truncated_text;

    // Shorten the author name if it's too long
    while (
      post.author_name.length > 16 &&
      post.author_name.split(" ").length > 1
    ) {
      post.author_name = post.author_name.split(" ").slice(0, -1).join(" ");
    }

    // Further shorten the author name if it's still too long
    if (post.author_name.length > 18) {
      const last_capital_index = post.author_name
        .split("")
        .reverse()
        .join("")
        .search(/[A-Z]/);
      post.author_name = post.author_name.slice(0, -last_capital_index);
    }

    // Assign random values to other post properties
    post.days_since_posted = Math.floor(Math.random() * 100);
    post.view_count = 100 + Math.floor(Math.random() * 100);
    post.like_count = 50 + Math.floor(Math.random() * 100);
    post.comment_count = 25 + Math.floor(Math.random() * 100);
    post.repost_count = 25 + Math.floor(Math.random() * 100);
  }
}
    /**
 * Generates a screen object based on the specified screen type.
 *
 * @param {string} screen_type - The type of screen to generate.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The number of posts to start in each feed.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @param {Object} weights - Weights for screen parameters.
 * @param {number} feature_count - The count of features.
 * @param {number} repeat_num - The repeat number of the same question and feature count.
 * @param {boolean} [is_practice=false] - Whether this is a practice screen or not.
 * @returns {Object|null} The generated screen object, or null if the screen type is not recognized.
 */
function generate_scored_screen_object(
  screen_type,
  base_posts,
  starting_num_posts,
  num_posts_to_load,
  weights,
  feature_count,
  repeat_num,
  is_practice = false,
  includes_confidence = false
) {
  let screen = null;

  switch (screen_type) {
    case "feed_comparison":
      screen = generate_feed_comparison_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice
      );
      break;
    case "post_placement":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
    case "post_placement_check_1":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
    case "post_placement_check_2":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
      case "post_placement_check_3":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
      case "post_placement_check_4":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
      case "post_placement_check_5":
      screen = generate_post_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice,
        includes_confidence
      );
      break;
    case "counterfactual_placement":
      screen = generate_counterfactual_placement_screen(
        screen_type,
        base_posts,
        starting_num_posts,
        num_posts_to_load,
        weights,
        feature_count,
        repeat_num,
        is_practice
      );
      break;
    case "post_arrangement":
      screen = generate_post_arrangement_screen(
        screen_type,
        starting_num_posts,
        num_posts_to_load,
        repeat_num,
        base_posts,
        weights,
        is_practice
      );
      break;
    default:
      console.error(`Screen type ${screen_type} not recognized`);
      break;
  }

  return screen;
}

/**
 * Generates a screen array based on input parameters.
 *
 * @param {string[]} question_screen_types - The array of screen types.
 * @param {Object[]} posts - The array of posts.
 * @param {number[]} feature_counts - The array of feature counts.
 * @param {number} num_same_features_and_question - The number of screen repetitions with the same feature count and question.
 * @param {string[]} feature_keys - The array of feature keys.
 * @param {number} num_posts - The number of posts in each screen.
 * @param {number} starting_num_posts - The number of posts to start in each feed.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @param {number} num_practice - Indicates whether to include practice screens.
 * @param {number[]} practice_confidence_indices - The array of indices for practice questions that include confidence.
 * @param {number[]} question_confidence_indices - The array of indices for real questions that include confidence.
 * 
 * @returns {Object[]} The generated screen array.
 */
function generate_screen_array(
  question_screen_types,
  posts,
  feature_counts,
  num_same_features_and_question,
  feature_keys,
  num_posts,
  starting_num_posts,
  num_posts_to_load,
  num_practice,
  practice_confidence_indices, 
  question_confidence_indices
) {
  const section_array = [];

  const introduction_screen = {
    screen_type: "introduction",
    template_id: "introduction",
  };

  section_array.push({
    section_name: "introduction",
    screens: [introduction_screen],
  });


  const shuffled_screen_types = deep_copy(question_screen_types);
  shuffle_array(shuffled_screen_types);

  // posts.forEach((post) => {
  //   post.character_count = post.text.length;
  // });

  const practice_array = [];
  const scored_screens_array = [];

  const weights = study_weights;

  let base_posts;
  let q_posts;
  let random_posts;
  if (bucketing && !set_posts) {
    let base_posts_indices = get_random_sample_indices_from_chunks(posts, Math.floor(posts.length/2), extreme=false);
    base_posts = base_posts_indices.map(idx => posts[idx]);
    q_posts = posts.filter((post, index) => !base_posts_indices.includes(index));
    // random_posts = get_random_sample(posts, 100);
    // base_posts = base_posts.filter((post) => post["Chunk"] !== 0);
  }
  else if (set_posts){
    base_posts = study_indices.slice(0,10).concat(study_indices.slice(50,60)).map(idx => posts[idx]);
    q_posts = study_indices.slice(10,50).concat(study_indices.slice(60,100)).map(idx => posts[idx]);
  } else {
    base_posts = get_random_sample(posts, max_num_posts_possible);
  }

  linear_combination_sort(base_posts, weights);

  // this clears out all of the zero weighted things
  const used_weights = Object.keys(deep_copy(weights)).reduce((result, key) => {
    if (weights[key] !== 0) {
      result[key] = weights[key];
    }
    return result;
  }, {});

  if (Object.keys(used_weights).length === 1 && !algorithms_already_created) {
    unsort_posts(base_posts, Object.keys(used_weights)[0], starting_num_posts - 1);
  } else {
    // I don't think we need to do anything, just don't unsort 
  }

  var check_posts = get_random_sample_from_chunks(q_posts, 10);
  var check_posts_1 = check_posts.slice(0,2);
  var check_posts_2 = check_posts.slice(2,4);
  var check_posts_3 = check_posts.slice(4,6);
  var check_posts_4 = check_posts.slice(6,8);
  var check_posts_5 = check_posts.slice(8);
  check_posts_1.forEach((post) => {
    post.attn_1 = true;
  });
  check_posts_2.forEach((post) => {
    post.attn_2 = true;
  });
  check_posts_3.forEach((post) => {
    post.attn_3 = true;
  });
  check_posts_4.forEach((post) => {
    post.attn_4 = true;
  });
  check_posts_5.forEach((post) => {
    post.attn_5 = true;
  });
  

  const check1 = generate_scored_screen_object(
    "post_placement_check_1",
    check_posts_1,
    starting_num_posts,
    0,
    weights,
    feature_counts[0],
    0,
    true,
    includes_confidence=false
  );
  const check2 = generate_scored_screen_object(
    "post_placement_check_2",
    check_posts_2,
    starting_num_posts,
    0,
    weights,
    feature_counts[0],
    1,
    true,
    includes_confidence=false
  );
  const check3 = generate_scored_screen_object(
    "post_placement_check_3",
    check_posts_3,
    starting_num_posts,
    0,
    weights,
    feature_counts[0],
    1,
    true,
    includes_confidence=false
  );
  const check4 = generate_scored_screen_object(
    "post_placement_check_4",
    check_posts_4,
    starting_num_posts,
    0,
    weights,
    feature_counts[0],
    1,
    true,
    includes_confidence=false
  );
  const check5 = generate_scored_screen_object(
    "post_placement_check_5",
    check_posts_5,
    starting_num_posts,
    0,
    weights,
    feature_counts[0],
    1,
    true,
    includes_confidence=false
  );

  const return_screen = {
    screen_type: "return_screen",
    template_id: "return_screen",
  };

  const exposure_intro_1 = generate_exposure_intro("exposure_intro_1");
  const exposure_intro_2 = generate_exposure_intro("exposure_intro_2");
  const exposure_intro_3 = generate_exposure_intro("exposure_intro_3");
  const exposure_intro_4 = generate_exposure_intro("exposure_intro_4");
  
  section_array.push({
    section_name: "training",
    // screens: [check1, check2, check3, check4, check5, return_screen, exposure_intro_1, exposure_intro_2, exposure_intro_3, exposure_intro_4],
    screens: [check1, check2, return_screen, exposure_intro_1, exposure_intro_2, exposure_intro_3, exposure_intro_4],
  });

  // const post_exposure_screen = generate_post_exposure_screen("post_exposure",
  //   random_posts,
  //   starting_num_posts,
  //   num_posts_to_load
  // );

  // section_array.push({
  //   section_name: "post_exposure",
  //   screens: [post_exposure_screen],
  // });


  const exposure_screen = generate_exposure_screen(
    "exposure",
    base_posts,
    starting_num_posts,
    num_posts_to_load
  );

  section_array.push({
    section_name: "exposure",
    screens: [exposure_screen],
  });

  // const practice_intro_screen = {
  //   screen_type: "practice_intro",
  //   template_id: "practice_intro",
  // };

  // section_array.push({
  //   section_name: "introduction",
  //   screens: [introduction_screen],
  // });

  
  // generate the practice

  for (let i = 0; i < shuffled_screen_types.length; i++) {
    const screen_type = shuffled_screen_types[i];
    for (
      let repeat_num = 1;
      repeat_num <= num_practice;
      repeat_num++
    ) {
      let base_posts;
      if (bucketing&& !set_posts) {
        base_posts = get_random_sample_from_chunks(q_posts, num_posts+1, extreme=false, required_diff=1);
      } else if (set_posts) {
          var chance = Math.random()
          if (chance > 0.5) {
            base_posts = q_posts.slice(0+repeat_num-1,0+repeat_num).concat(q_posts.slice(40+repeat_num-1,40+repeat_num));
          } else {
            base_posts = q_posts.slice(40+repeat_num-1,40+repeat_num).concat(q_posts.slice(0+repeat_num-1,0+repeat_num));
          }
      }
      else {
        base_posts = get_random_sample(posts, num_posts+1);
        // base_posts = deep_copy(posts)
      }

      //(base_posts, weights);
      var includes_confidence = (practice_confidence_indices.includes(repeat_num));
      const screen = generate_scored_screen_object(
        screen_type,
        base_posts,
        starting_num_posts,
        0,
        weights,
        feature_counts[0],
        repeat_num,
        true,
        includes_confidence=includes_confidence
      );

      if (screen) {
        practice_array.push(screen);
      }
    }
  }

  const practice_intro_screen = {
    screen_type: "practice_intro",
    template_id: "practice_intro",
  };


  section_array.push({
    section_name: "practice",
    screens: [practice_intro_screen].concat(practice_array),
  });





  // in here, generate scored screen object for real screens

  // var attn_1 = Math.floor(Math.random() * num_same_features_and_question);
  // var attn_2 = Math.floor(Math.random() * num_same_features_and_question);
  var attn_1 = -1
  var attn_2 = -1

  for (let i = 0; i < shuffled_screen_types.length; i++) {
    const screen_type = shuffled_screen_types[i];
    for (
      let repeat_num = 1;
      repeat_num <= num_same_features_and_question;
      repeat_num++
    ) {
      let base_posts;
      let temp_screen_type = screen_type;
      if (bucketing&& !set_posts) {
        base_posts = get_random_sample_from_chunks(q_posts, num_posts+1, extreme=false, required_diff=1);
      } else if (set_posts) {
          var chance = Math.random()
          if (chance > 0.5) {
            base_posts = q_posts.slice(10+repeat_num-1,10+repeat_num).concat(q_posts.slice(50+repeat_num-1,50+repeat_num));
          } else {
            base_posts = q_posts.slice(50+repeat_num-1,50+repeat_num).concat(q_posts.slice(10+repeat_num-1,10+repeat_num));
          }
      }
      else {
        base_posts = get_random_sample(posts, num_posts+1);
        // base_posts = deep_copy(posts)
      }

      if (repeat_num == attn_1) {
        temp_screen_type = "post_placement_check_1";
        base_posts.forEach((post) => {
          post.attn_1 = true;
        });
      } else if (repeat_num == attn_2) {
        temp_screen_type = "post_placement_check_2";
        base_posts.forEach((post) => {
          post.attn_2 = true;
        });
      }

      var includes_confidence = (question_confidence_indices.includes(repeat_num));
      //(base_posts, weights);

      const screen = generate_scored_screen_object(
        temp_screen_type,
        base_posts,
        starting_num_posts,
        0,
        weights,
        feature_counts[0],
        repeat_num,
        false,
        includes_confidence=includes_confidence
      );

      if (screen) {
        scored_screens_array.push(screen);
      }
    }
  }

  const questions_intro_screen = {
    screen_type: "questions_intro",
    template_id: "questions_intro",
  };


  section_array.push({
    section_name: "questions",
    screens: [questions_intro_screen].concat(scored_screens_array),
  });



  const feedback_screen = generate_feedback_screen("feedback");
  const feedback_screen2 = generate_feedback_screen("feedback_2");
  const feedback_screen3 = generate_feedback_screen("feedback_3");
  const feedback_screen4 = generate_feedback_screen("feedback_4");
  const feedback_screen5 = generate_feedback_screen("feedback_5");

  section_array.push({
    section_name: "feedback",
    screens: [feedback_screen, feedback_screen2, feedback_screen3, feedback_screen4, feedback_screen5],
  });

  const submission_screen = {
    screen_type: "submission",
    template_id: "submission",
  };

  section_array.push({
    section_name: "submission",
    screens: [submission_screen],
  });

  return section_array;
}
    /**
 * Unsorts posts based on remaining features.
 *
 * @param {Object[]} posts - An array of post objects.
 * @param {string} feature_to_ignore - The feature to ignore while unsorting.
 * @param {number} [first_num_posts_to_change=posts.length] - The number of posts to change starting from the first post.
 * @throws {Error} If the input is invalid or the specified feature_to_ignore does not exist in the post objects.
 */
function unsort_posts(
  posts,
  feature_to_ignore,
  first_num_posts_to_change = posts.length
) {
  if (!Array.isArray(posts) || typeof feature_to_ignore !== "string") {
    throw new Error(
      "Invalid input. Expecting an array of posts and a string for feature_to_ignore."
    );
  }

  const feature_keys = Object.keys(posts[0]);
  if (!feature_keys.includes(feature_to_ignore)) {
    throw new Error(
      "The specified feature_to_ignore does not exist in the post objects."
    );
  }

  const remaining_feature_keys = feature_keys.filter(
    (key) => key !== feature_to_ignore
  );

  const is_sorted_by_feature_increasing = (feature) => {
    for (let i = 1; i < first_num_posts_to_change; i++) {
      if (
        posts[i].hasOwnProperty(feature) &&
        posts[i][feature] < posts[i - 1][feature]
      ) {
        return false;
      }
    }
    return true;
  };

  const is_sorted_by_feature_decreasing = (feature) => {
    for (let i = 1; i < first_num_posts_to_change; i++) {
      if (
        posts[i].hasOwnProperty(feature) &&
        posts[i][feature] > posts[i - 1][feature]
      ) {
        return false;
      }
    }
    return true;
  };

  const MAX_ATTEMPTS = 1000;

  for (const feature of remaining_feature_keys) {
    let attempts = 0;

    while (
      (is_sorted_by_feature_increasing(feature) ||
        is_sorted_by_feature_decreasing(feature)) &&
      attempts < MAX_ATTEMPTS
    ) {
      let index1, index2;
      do {
        index1 = Math.floor(Math.random() * first_num_posts_to_change);
        index2 = Math.floor(Math.random() * first_num_posts_to_change);
      } while (index1 === index2);

      if (
        posts[index1].hasOwnProperty(feature) &&
        posts[index2].hasOwnProperty(feature)
      ) {
        const temp = posts[index1][feature];
        posts[index1][feature] = posts[index2][feature];
        posts[index2][feature] = temp;

        if (
          feature === "character_count" &&
          posts[index1].hasOwnProperty("text") &&
          posts[index2].hasOwnProperty("text")
        ) {
          const text_temp = posts[index1]["text"];
          posts[index1]["text"] = posts[index2]["text"];
          posts[index2]["text"] = text_temp;
        }
      }

      attempts++;
    }

    if (attempts === MAX_ATTEMPTS) {
      console.warn(
        `Reached maximum number of attempts (${MAX_ATTEMPTS}) for unsorting posts by feature ${feature}.`
      );
    }
  }
}

/**
 * Generates random weights for the given features.
 *
 * @param {string[]} features - The array of feature names.
 * @param {number} num_features - The number of features to have non-zero weight.
 * @param {boolean} [magnitude_one=false] - Whether all weights should have a magnitude of 1.
 * @param {boolean} [algorithms_already_created=false] - Whether algorithm has been precomputed and should have weight = 1.
 * @param {string} [alg=null] - The name of the precomputed algorithm condition
 * @returns {Object} The randomly generated weights object.
 * @throws {Error} If the number of features is greater than the total number of features.
 */
function generate_weights(features, num_features, magnitude_one = false, algorithms_already_created = false, alg = null) {
  if (num_features > features.length) {
    throw new Error(
      "The number of features cannot be greater than the total number of features."
    );
  }

  const weights = {};
  let num_features_set = 0;

  if (algorithms_already_created){
    weights[alg] = 1
  } else {
    while (num_features_set < num_features) {
      const random_feature =
        features[Math.floor(Math.random() * features.length)];
      if (weights[random_feature] === undefined) {
        if (magnitude_one) {
          weights[random_feature] = Math.random() < 0.5 ? -1 : 1;
        } else {
          do {
            weights[random_feature] = truncate(Math.random() * 2 - 1);
          } while (Math.abs(weights[random_feature]) <= 0.1);
        }
        num_features_set++;
      }
    }

    if (Object.keys(weights).length === 1) {
      const key = Object.keys(weights)[0];
      weights[key] = weights[key] >= 0 ? 1 : -1;
    }
  }

  for (const feature of features) {
    if (weights[feature] === undefined) {
      weights[feature] = 0;
    }
  }

  return weights;
}

/**
 * Sorts a feed array of posts based on the provided weights.
 *
 * @param {Object[]} feed - The feed array of posts to be sorted.
 * @param {Object} weights - The weights object for features.
 */
function linear_combination_sort(feed, weights) {
  feed.sort((a, b) => {
    let a_score = 0;
    let b_score = 0;
    for (const key in weights) {
      if (key === "character_count") {
        a_score += weights[key] * a["text"].length;
        b_score += weights[key] * b["text"].length;
      } else if (weights[key] != 0){
        a_score += weights[key] * a[key];
        b_score += weights[key] * b[key];
      }
    }
    return b_score - a_score;
  });
}

/**
 * Modifies the weights object by changing one of the weights.
 *
 * @param {Object} weights - The weights object to be modified.
 * @returns {string} The name of the weight that was changed.
 */
function permute_weights(weights) {
  const keys = Object.keys(weights);
  const random_key = keys[Math.floor(Math.random() * keys.length)];
  weights[random_key] = truncate(Math.random() * 2 - 1);
  return random_key;
}

/**
 * Returns the name of a randomly selected non-zero weight from the weights object.
 *
 * @param {Object} weights - The weights object.
 * @returns {string} The name of the selected non-zero weight.
 */
function get_random_nonzero_weight(weights) {
  const keys = Object.keys(weights);
  let random_key = keys[Math.floor(Math.random() * keys.length)];
  while (weights[random_key] === 0) {
    random_key = keys[Math.floor(Math.random() * keys.length)];
  }
  return random_key;
}

/**
 * Modifies the weights object by changing the sign of one of the weights.
 *
 * @param {Object} weights - The weights object to be modified.
 * @returns {string} The name of the weight that was changed.
 */
function permute_weights_valence(weights) {
  const keys = Object.keys(weights);
  const random_key = keys[Math.floor(Math.random() * keys.length)];

  if (weights[random_key] === 0) {
    do {
      weights[random_key] = truncate(Math.random() * 2 - 1);
    } while (Math.abs(weights[random_key]) <= 0.1);
  } else {
    weights[random_key] = -weights[random_key];
  }

  return random_key;
}

/**
 * Inserts a duplicate screen into the screen array.
 *
 * @param {Object[]} screen_array - The screen array.
 * @param {number} num_repeats - The number of repetitions with the same feature count and questions.
 * @param {number} num_feature_counts - The number of feature counts.
 */
function insert_duplicate_screen(
  screen_array,
  num_repeats,
  num_feature_counts
) {
  const source_index = screen_array.length - num_repeats * num_feature_counts;
  const screen = deep_copy(screen_array[source_index]);
  const random_index =
    source_index +
    3 +
    Math.floor(Math.random() * (num_repeats * num_feature_counts - 3));
  screen_array.splice(random_index, 0, screen);
}

/**
 * Generates a screen name based on screen information.
 *
 * @param {Object} screen_info - The screen information object.
 * @returns {string} The generated screen name.
 */
function generate_screen_name(screen_info) {
  let screen_name = `study-${screen_info.screen_type}-features-${screen_info["feature_count"]}-${screen_info["instance_number"]}`;

  if (screen_info.screen_type === "introduction") {
    screen_name = "introduction";
  } else if (screen_info.screen_type === "submission") {
    screen_name = "submission";
  } else if (screen_info.screen_type === "exposure") {
    screen_name = "exposure";
  } else if (screen_info.screen_type === "feedback") {
    screen_name = "feedback";
  }

  return screen_name;
}

function assign_extra_posts_to_buckets(posts_left_over, num_buckets, required_diff=1){
  var buckets_with_extra = []
  var buckets = [];
  for (var i=0;i<num_buckets;i++) {
    buckets.push(i);
}
  var count = 0;
  var difference = 0;
  while (required_diff>difference && count < 10){
    count++;
    var buckets_util = buckets.slice();
    buckets_with_extra = [];
    for (let i = 0; i < posts_left_over; i+= 1) {
      let random_bucket = Math.floor(Math.random() * buckets_util.length);
      buckets_with_extra.push(buckets_util[random_bucket]);
      buckets_util.splice(random_bucket, 1);
    }
    if (posts_left_over==2) {
      difference = Math.abs(buckets_with_extra[0]-buckets_with_extra[1]);
    } else {
      difference = required_diff+1;
    }
  }
  return buckets_with_extra;
}


function generate_posts_from_buckets(data, num_buckets, max_num_posts_possible, extreme=false) {

  var length_of_buckets = Math.floor(data.length / num_buckets)
  var posts_per_bucket = Math.floor(max_num_posts_possible / num_buckets)
  var posts_left_over = max_num_posts_possible - (posts_per_bucket * num_buckets)

  var buckets_with_extra = assign_extra_posts_to_buckets(posts_left_over, num_buckets)


  var chunks = []
  var sampled_chunks = []

  let index = 0
  for (let b=0; b < num_buckets; b+=1) {
    var extra = (b in buckets_with_extra) ? 1 : 0;
    var chunk = data.slice(index, index + posts_per_bucket + extra);
    sampled_chunks.push(chunk);
    index+= chunk.length;
  }
  // for (let i = 0; i < data.length; i += length_of_buckets) {
  //   if (count == num_buckets - 1) {
  //     var chunk = data.slice(i);
  //   }
  //   else {
  //     var extra = ()
  //     var chunk = data.slice(i, i + length_of_buckets);
  //   }
  //   sampled_chunks.push(chunk)

  //   if (buckets_with_extra.includes(count)) {
  //     let num_to_add = buckets_with_extra.reduce((n, x) => n + (x === count), 0);
  //     console.log(num_to_add);
  //     sampled_chunks.push(get_random_sample(chunk, posts_per_bucket + num_to_add))
  //   }
  //   else {
  //     sampled_chunks.push(get_random_sample(chunk, posts_per_bucket))
  //   }
  //   if (count == num_buckets - 1) {
  //     break;
  //   }
  //   count += 1;
  // }


  var post_count = 0;
  var sampled_chunks_flattened = []
  for (let i = 0; i < sampled_chunks.length; i += 1) {
    for (let j = 0; j < sampled_chunks[i].length; j +=1) {
      sampled_chunks[i][j]["Chunk"] = i
      if (!extreme || i==0 || i==sampled_chunks.length-1) {
        sampled_chunks[i][j]["full_index"] = post_count;
        sampled_chunks_flattened.push(sampled_chunks[i][j])
      } else {
      }
      post_count += 1
    }
  }

  for (let i = 0; i < sampled_chunks_flattened.length; i += 1) {
    sampled_chunks_flattened[i]["Index"] = i;
  }

  return sampled_chunks_flattened

}
// get a random sample of posts from flattened chunked data
function get_random_sample_from_chunks(data, num_posts, extreme=false, required_diff=1) {
  chunked_data = create_chunked_data(data, extreme)
  var num_buckets = chunked_data.length;
  var posts_per_bucket = Math.floor(num_posts / num_buckets)
  var posts_left_over = num_posts - (posts_per_bucket * num_buckets)

  var buckets_with_extra = assign_extra_posts_to_buckets(posts_left_over, num_buckets, required_diff=required_diff);

  var sampled_chunks = [];

  for (let i = 0; i < chunked_data.length; i++) {

    if (buckets_with_extra.includes(i)) {
      let num_to_add = buckets_with_extra.reduce((n, x) => n + (x === i), 0);
      sampled_chunks.push(get_random_sample(chunked_data[i], posts_per_bucket + num_to_add));
    }
    else {
      sampled_chunks.push(get_random_sample(chunked_data[i], posts_per_bucket));
    }
  }

  var sampled_chunks_flattened = []
  for (let i = 0; i < sampled_chunks.length; i += 1) {
    for (let j = 0; j < sampled_chunks[i].length; j +=1) {
      sampled_chunks_flattened.push(sampled_chunks[i][j]);
    }
  }

  return sampled_chunks_flattened
}
// from flattened bucketed data, put into chunks
function create_chunked_data(data, extreme=false) {
  new_dict = {}

  for (let i = 0; i < data.length; i+=1) {
    if (!(data[i]["Chunk"] in new_dict)) {
      new_dict[data[i]["Chunk"]] = [];
    }
    new_dict[data[i]["Chunk"]].push(data[i]);
  }
  new_list = []
  for (var key in new_dict) {
    new_list.push(new_dict[key]);
  }
  if (extreme) {
    new_list = [new_list[0], new_list[new_list.length -1]];
  }
  return new_list
}

// given flattened, pre-computed chunked data, return a set of indices randomly sampled across chunks
function get_random_sample_indices_from_chunks(data, num_posts, extreme = false) {
    sampled_chunks_flattened = get_random_sample_from_chunks(data, num_posts, extreme=extreme)
    indicies = []
    for (let i = 0; i < sampled_chunks_flattened.length; i += 1) {
      indicies.push(sampled_chunks_flattened[i]["Index"])
    }
    return indicies
}


    /**
 * Generates a Counterfactual Placement screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load.
 * @param {Object} weights - The weights for features.
 * @param {number} feature_count - The feature count.
 * @param {number} repeat_num - The repetition number.
 * @param {boolean} [is_practice=false] - Indicates if it's a practice screen.
 * @returns {Object} The Counterfactual Placement screen object.
 */
function generate_counterfactual_placement_screen(
  screen_type,
  base_posts,
  starting_num_posts,
  num_posts_to_load,
  weights,
  feature_count,
  repeat_num,
  is_practice = false,
  includes_confidence = false
) {
  const MAX_ITERATIONS = 1000;
  let iteration_count = 0;

  const posts = deep_copy(base_posts);
  const post_index = Math.floor(Math.random() * (num_posts_to_load - 2)) + 1;
  const post = deep_copy(posts[post_index]);
  let new_post;
  let dummy_feed;

  const higher_same_lower = [-1, 0, 1][Math.floor(Math.random() * 3)];
  let change_direction;
  let highlighted_feature;

  do {
    if (iteration_count >= MAX_ITERATIONS) {
      console.warn(
        "Maximum iteration limit reached. Consider checking your logic."
      );
      break;
    }

    new_post = deep_copy(post);
    highlighted_feature =
      Object.keys(weights)[
        Math.floor(Math.random() * Object.keys(weights).length)
      ];

    dummy_feed = deep_copy(posts);
    dummy_feed.splice(post_index, 1);

    if (highlighted_feature === "character_count") {
      const generic_texts = [
        "Hoc est admirabile, dignum admiratione!",
        "Incredibile! Omnes oculi convergent!",
        "Mirum est initium, omne initium difficilimum.",
        "Vivamus, cogitemus, amemus! Vita brevis est.",
        "Sapientia est potentia in omni tempore.",
        "Tempus fugit, carpe diem! Hauriamus ex momento.",
        "Amicitia vinculum aureum, preciosa et duratura.",
        "Per aspera ad astra. Virtus in difficultatibus crescit.",
      ];

      const text = new_post["text"];

      if (Math.random() < 0.5) {
        const words = text.split(" ");
        const words_to_remove = Math.floor(Math.random() * words.length);
        const new_text = words
          .slice(0, words.length - words_to_remove)
          .join(" ");
        new_post["text"] = new_text;
      } else {
        const random_index = Math.floor(Math.random() * generic_texts.length);
        const selected_text = generic_texts[random_index];
        new_post["text"] = text + " " + selected_text;
      }
    } else {
      new_post[highlighted_feature] = Math.floor(
        new_post[highlighted_feature] * Math.random() * 5
      );
    }

    new_post["highlighted_feature"] = highlighted_feature;
    dummy_feed.push(new_post);
    linear_combination_sort(dummy_feed, weights);

    const change_in_index = post_index - dummy_feed.indexOf(new_post);
    change_direction =
      change_in_index === 0 ? 0 : change_in_index / Math.abs(change_in_index);

    iteration_count++;
  } while (change_direction !== higher_same_lower || new_post === post);

  posts[post_index]["highlighted_feature"] = highlighted_feature;

  const screen = {
    screen_type: screen_type,
    feature_count: feature_count,
    instance_number: repeat_num,
    is_practice: is_practice,
    template_id: SCREEN_TYPE_INFO[screen_type].template_id,
    feeds: [posts],
    weights: weights,
    starting_num_posts: starting_num_posts,
    num_posts_to_load: num_posts_to_load,
    new_post: new_post,
    new_post_higher_same_lower: higher_same_lower,
  };

  return screen;
}
    /**
 * Generates an algorithm exposure screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @returns {Object} The Exposure screen object.
 */
function generate_exposure_screen(
  screen_type,
  base_posts,
  starting_num_posts,
  num_posts_to_load
) {
  const sidebar_entries = deep_copy(
    SCREEN_TYPE_INFO[screen_type].sidebar_entries
  );

  const screen = {
    screen_type: screen_type,
    template_id: SCREEN_TYPE_INFO.exposure.template_id,
    feeds: [base_posts],
    starting_num_posts: starting_num_posts,
    num_posts_to_load: num_posts_to_load,
    sidebar_entries: sidebar_entries,
    labels: ["Your Politics Feed"],
    // labels: ["Your Feed"],
  };

  return screen;
}
    /**
 * Generates a user feedback screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @returns {Object} The Feedback screen object.
 */
function generate_exposure_intro(screen_type) {
    const screen = {
      screen_type: screen_type,
      template_id: SCREEN_TYPE_INFO[screen_type].template_id,
      sidebar_entries: deep_copy(SCREEN_TYPE_INFO[screen_type].sidebar_entries),
      is_practice: true,
      feeds: [],
    };
    return screen;
  }
  
    /**
 * Generates an post exposure screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @returns {Object} The Exposure screen object.
 */
function generate_post_exposure_screen(
    screen_type,
    base_posts,
    starting_num_posts,
    num_posts_to_load
  ) {
    const sidebar_entries = deep_copy(
      SCREEN_TYPE_INFO[screen_type].sidebar_entries
    );
  
    const screen = {
      screen_type: screen_type,
      template_id: SCREEN_TYPE_INFO.exposure.template_id,
      feeds: [base_posts],
      starting_num_posts: starting_num_posts,
      num_posts_to_load: num_posts_to_load,
      sidebar_entries: sidebar_entries,
      labels: ["Sample Posts"],
    };
  
    return screen;
  }
  
    /**
 * Generates a screen object for showing the user the correct response.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @returns {Object} The generated screen object.
 */
function generate_correct_response_screen(
  screen_type,
  base_posts,
  starting_num_posts,
  num_posts_to_load
) {
  base_posts = deep_copy(base_posts);
  const sidebar_entries = deep_copy(
    SCREEN_TYPE_INFO[screen_type].sidebar_entries
  );

  sidebar_entries.forEach((entry) => {
    if (entry.answer_area === "post_bank") {
      entry["post_bank"] = base_posts;
    }
  });

  const screen = {
    screen_type: screen_type,
    template_id: SCREEN_TYPE_INFO.exposure.template_id,
    starting_num_posts: starting_num_posts,
    feeds: [],
    num_posts_to_load: num_posts_to_load,
    sidebar_entries: sidebar_entries,
    labels: ["Your Ordering"],
  };

  return screen;
}
    /**
 * Generates a feed comparison screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} base_posts - An array of base posts.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load.
 * @param {Object} weights - The weights for features.
 * @param {number} feature_count - The feature count.
 * @param {number} repeat_num - The repetition number.
 * @param {boolean} [is_practice=false] - Indicates if it's a practice screen.
 * @returns {Object} The Feed Comparison screen object.
 */
function generate_feed_comparison_screen(
  screen_type,
  base_posts,
  starting_num_posts,
  num_posts_to_load,
  weights,
  feature_count,
  repeat_num,
  is_practice = false,
  includes_confidence = false
) {
  base_posts = deep_copy(base_posts);
  const comparison_posts = get_random_sample(
    source_posts,
    base_posts.length,
    base_posts
  );
  linear_combination_sort(comparison_posts, weights);
  const same_sort_b = JSON.stringify(comparison_posts);

  let permuted = Math.random() > 0.5;
  const permuted_weights = deep_copy(weights);
  if (permuted) {
    do {
      permute_weights_valence(permuted_weights);
      linear_combination_sort(comparison_posts, permuted_weights);
    } while (JSON.stringify(comparison_posts) === same_sort_b);
  }

  const used_permuted_weights = Object.keys(deep_copy(permuted_weights)).reduce(
    (result, key) => {
      if (permuted_weights[key] !== 0) {
        result[key] = permuted_weights[key];
      }
      return result;
    },
    {}
  );

  if (Object.keys(used_permuted_weights).length === 1) {
    unsort_posts(
      comparison_posts,
      Object.keys(used_permuted_weights)[0],
      starting_num_posts - 1
    );
  }

  const screen = {
    screen_type: screen_type,
    feature_count: feature_count,
    instance_number: repeat_num,
    is_practice: is_practice,
    template_id: SCREEN_TYPE_INFO[screen_type].template_id,
    feeds: [base_posts, comparison_posts],
    weights: weights,
    starting_num_posts: starting_num_posts,
    num_posts_to_load: num_posts_to_load,
    permuted: permuted,
    permuted_weights: permuted_weights,
    labels: ["Your Feed Today", "Your Feed Tomorrow"],
  };

  return screen;
}
    /**
 * Generates a post placement screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {Object[]} all_posts - An array of posts including the base and one to place.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load.
 * @param {Object} weights - The weights for features.
 * @param {number} feature_count - The feature count.
 * @param {number} repeat_num - The repetition number.
 * @param {boolean} [is_practice=false] - Indicates if it's a practice screen.
 * @returns {Object} The Post Placement screen object.
 */
function generate_post_placement_screen(
  screen_type,
  all_posts,
  starting_num_posts,
  num_posts_to_load,
  weights,
  feature_count,
  repeat_num,
  is_practice = false,
  includes_confidence = false,
) {
  // base_posts = deep_copy(base_posts);
  // let new_post_index = base_posts.length;
  // let new_post = get_random_sample(source_posts, 1, base_posts)[0];
  // let all_posts = [...base_posts, new_post];

  all_posts = deep_copy(all_posts);
  let new_post_index = Math.floor(Math.random()*all_posts.length)
  let ref_post_index = (new_post_index==1) ? 0 : 1;
  let new_post = all_posts[new_post_index];
  let base_posts = (new_post_index==1) ? all_posts.slice(0, -1) : all_posts.slice(1);


  if (bucketing) {
    linear_combination_sort(all_posts, weights);
    new_post_index = all_posts.indexOf(new_post);
    // opposite of new post
    ref_post_index = (new_post_index==1) ? 0 : 1;
  }
  else {
    while (new_post_index >= num_posts_to_load) {
      new_post = get_random_sample(source_posts, 1, base_posts)[0];
      if (base_posts.indexOf(new_post) !== -1) {
        continue;
      }
      all_posts = [...base_posts, new_post];
      linear_combination_sort(all_posts, weights);
      new_post_index = all_posts.indexOf(new_post);
    }
  }

  correct_posts = deep_copy(all_posts)

  const without_new_post = (new_post_index==1) ? correct_posts.slice(0, -1) : correct_posts.slice(1);
  var sidebar_entries = deep_copy(
    SCREEN_TYPE_INFO[screen_type].sidebar_entries
  );
  sidebar_entries[0]["includes_confidence"] = includes_confidence;
  new_post["correct_index"] = new_post_index;
  new_post["correct_position"] = new_post_index;
  without_new_post[0]["correct_position"] = ref_post_index;

  sidebar_entries.forEach((entry) => {
    if (entry.answer_area === "post_bank") {
      // entry["post_bank"] = [new_post].concat(without_new_post);
      entry["post_bank"] = [new_post]
    }
  });

  const screen = {
    screen_type: screen_type,
    feature_count: feature_count,
    instance_number: repeat_num,
    is_practice: is_practice,
    template_id: SCREEN_TYPE_INFO[screen_type].template_id,
    weights: weights,
    feeds: [without_new_post],
    // feeds: [[]],
    starting_num_posts: starting_num_posts,
    num_posts_to_load: num_posts_to_load,
    correct_posts: correct_posts,
    sidebar_entries: sidebar_entries,
    labels: ["Your Ordering"],
  };

  // const screen = {
  //   screen_type: screen_type,
  //   feature_count: feature_count,
  //   instance_number: repeat_num,
  //   is_practice: is_practice,
  //   template_id: SCREEN_TYPE_INFO[screen_type].template_id,
  //   weights: weights,
  //   feeds: [without_new_post],
  //   starting_num_posts: starting_num_posts,
  //   num_posts_to_load: num_posts_to_load,
  //   correct_posts: correct_posts,
  //   sidebar_entries: sidebar_entries,
  //   labels: ["Your Ordering"],
  // };

  return screen;
}
    /**
 * Generates a Post Placement screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @param {number} starting_num_posts - The starting number of posts.
 * @param {number} num_posts_to_load - The number of posts to load with each "load more".
 * @param {number} repeat_num - The repetition number.
 * @param {Object[]} posts - The array of posts.
 * @param {Object} weights - The weights for features.
 * @param {boolean} [is_practice=false] - Indicates if it's a practice screen.
 * @returns {Object} The Post Placement screen object.
 */
function generate_post_arrangement_screen(
  screen_type,
  starting_num_posts,
  num_posts_to_load,
  repeat_num,
  posts,
  weights,
  is_practice = false,
  includes_confidence = false
) {
  posts = deep_copy(posts);
  const correct_posts = deep_copy(posts);

  posts.forEach((post, index) => {
    post["correct_position"] = index;
  });
  shuffle_array(posts);

  const sidebar_entries = deep_copy(
    SCREEN_TYPE_INFO[screen_type].sidebar_entries
  );

  sidebar_entries.forEach((entry) => {
    if (entry.answer_area === "post_bank") {
      entry["post_bank"] = posts;
    }
  });

  const screen = {
    screen_type: screen_type,
    feature_count: 1,
    instance_number: repeat_num,
    is_practice: is_practice,
    template_id: SCREEN_TYPE_INFO[screen_type].template_id,
    weights: weights,
    feeds: [[]],
    starting_num_posts: starting_num_posts,
    num_posts_to_load: num_posts_to_load,
    sidebar_entries: sidebar_entries,
    correct_posts: correct_posts,
    labels: ["Your Ordering"],
  };

  return screen;
}
    /**
 * Generates a user feedback screen object.
 *
 * @param {string} screen_type - The type of screen.
 * @returns {Object} The Feedback screen object.
 */
function generate_feedback_screen(screen_type) {
  const screen = {
    screen_type: screen_type,
    template_id: SCREEN_TYPE_INFO[screen_type].template_id,
    entries: deep_copy(SCREEN_TYPE_INFO[screen_type].entries),
  };

  return screen;
}

    /**
 * Joins an array into a string with comma and space separators.
 *
 * @param {Array} array - The array to be converted to a string.
 * @returns {string} The joined string.
 */
function array_to_string(array) {
  return array.join(", ");
}

/**
 * Merges two objects into a new object.
 *
 * @param {Object} obj1 - The first object.
 * @param {Object} obj2 - The second object.
 * @returns {Object} The merged object.
 */
function merge_objects(obj1, obj2) {
  const result = {};
  for (const key in obj1) {
    result[key] = obj1[key];
  }
  for (const key in obj2) {
    result[key] = obj2[key];
  }
  return result;
}

/**
 * Gets a random element from an array.
 *
 * @param {Array} array - The array.
 * @returns {*} A random element from the array.
 */
function get_random_element(list) {
  return list[Math.floor(Math.random() * list.length)];
}

/**
 * Shuffles an array using the Fisher-Yates algorithm.
 *
 * @param {Array} array - The array to be shuffled.
 */
function shuffle_array(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

/**
 * Truncates a number to two decimal points.
 *
 * @param {number} number - The number to be truncated.
 * @returns {number} The truncated number.
 */
function truncate(number) {
  return Math.round(number * 10) / 10;
}

/**
 * Deep copy of an object or an array.
 *
 * @param {Object|Array} obj - The object or array to be copied.
 * @returns {Object|Array} The deep copy of the input.
 */
function deep_copy(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => deep_copy(item));
  } else if (typeof obj === "object" && obj !== null) {
    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => [key, deep_copy(value)])
    );
  }
  return obj;
}

/**
 * Generates random deep-copied samples from the provided data array, excluding specified posts.
 *
 * @param {Array} data - The array from which to select random samples.
 * @param {number} sample_size - The number of random samples to generate.
 * @param {Array} excluded_posts - Posts that should not be included in the new sample.
 * @returns {Array} An array containing deep-copied random samples.
 */
function get_random_sample(data, sample_size, excluded_posts = []) {
  if (data.length <= sample_size) {
    return deep_copy(data);
  }

  const availablePosts = data.filter(
    (post) =>
      !excluded_posts.some((excludedPost) => isEqual(excludedPost, post))
  );
  const samples = new Set();

  while (samples.size < sample_size && availablePosts.length > 0) {
    const randomIndex = Math.floor(Math.random() * availablePosts.length);
    const randomPost = availablePosts[randomIndex];

    if (!samples.has(JSON.stringify(randomPost))) {
      samples.add(JSON.stringify(randomPost));
    }
  }

  return Array.from(samples).map((post) => JSON.parse(post));
}

// Helper function for deep equality check
function isEqual(objA, objB) {
  return JSON.stringify(objA) === JSON.stringify(objB);
}

function format_number_for_display(feature) {
  if (!isNaN(parseFloat(feature)) && isFinite(feature)){
    var symbol = ["", "K", "M", "B", "T"];
    var tier = Math.log10(Math.abs(feature)) / 3 | 0;
    // if zero, we don't need a suffix
    if(tier == 0) return feature;
    // get suffix and determine scale
    var suffix = symbol[tier];
    var scale = Math.pow(10, tier * 3);
    // scale the number
    var scaled = feature / scale;
    // format number and add suffix
    return scaled.toFixed(1) + suffix;
  } else {
    return feature
  }
}

/**
 * Converts a string to an RGB color based on a hash function.
 *
 * @param {string} string - The input string.
 * @returns {Array} An array containing the RGB values [r, g, b].
 */
function string_to_rgb(string) {
  // Simple hash function to convert the string to a numeric value
  function hash_string(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return hash;
  }

  // Convert the hash value to RGB values within the range [0, 255]
  function int_to_rgb(i) {
    const c = (i & 0x00ffffff).toString(16).toUpperCase();
    return "00000".substring(0, 6 - c.length) + c;
  }

  // Generate a numeric hash value from the input string
  const hash_value = hash_string(string);

  // Convert the hash value to RGB values
  const rgb_string = int_to_rgb(hash_value);

  // Extract the RGB values and convert them to an array
  const r = parseInt(rgb_string.slice(0, 2), 16);
  const g = parseInt(rgb_string.slice(2, 4), 16);
  const b = parseInt(rgb_string.slice(4, 6), 16);

  return [r, g, b];
}
    // Global Variables
let curr_section_index = 0;
let curr_screen_index = 0;

start_time = new Date();

const output = {};
output["global"] = []; // output["global"].push({ concept_index: concept_index });
output["global"].push({condition: condition});
output["global"].push({url: window.location.href});

const params = new URLSearchParams(window.location.search);
const PID = params.get("PARTICIPANT_ID");
const STUDY_ID = params.get("STUDY_ID");
const SESSION_ID = params.get("SESSION_ID");
output["global"].push({pid: PID});
output["global"].push({study_id: STUDY_ID});
output["global"].push({session_id: SESSION_ID});
output["global"].push({posts: study_indices});
output["global"].push({study_condition: condition_chosen});

// output["global"].push({ linear_combination_sort: study_weights });

// sanitize_posts(source_posts);

const study_array = generate_screen_array(
  question_screen_types,
  source_posts,
  [get_random_element(possible_num_features)],
  num_same_features_and_question,
  feature_keys,
  num_posts_per_screen,
  num_posts_at_load,
  num_posts_to_load,
  num_practice,
  practice_confidence_indices,
  question_confidence_indices
);

// console.log(study_array);

study_array[0]["start_time"] = new Date().getTime();
study_array[0].screens[0]["start_time"] = new Date().getTime();

display_screen(
  study_array[0].screens[0],
  "introduction",
  study_array[0].section_name
);
  </script>

</body>
</html>
